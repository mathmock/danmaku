<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>å¼¾å¹•ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°</title>
  <style>
    :root {
      --bg-color: #fff;
      --fg-color: #000;
      --bg-secondary: #f0f0f0;
      --fg-secondary: #333;
      --accent-color: #666;
    }
    .dark-mode {
      --bg-color: #000;
      --fg-color: #fff;
      --bg-secondary: #111;
      --fg-secondary: #ccc;
      --accent-color: #999;
    }
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: var(--bg-color);
    }
    #gameContainer {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    canvas {
      display: block;
      background: var(--bg-color);
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      right: 60px;
      display: flex;
      justify-content: space-between;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      color: var(--fg-color);
      pointer-events: none;
    }
    #bombBtn {
      position: absolute;
      bottom: 30px;
      right: 30px;
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: var(--fg-color);
      color: var(--bg-color);
      font-family: 'Courier New', monospace;
      font-size: 12px;
      font-weight: bold;
      border: 3px solid var(--accent-color);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    #bombBtn:active {
      opacity: 0.7;
    }
    #bombBtn.disabled {
      opacity: 0.5;
    }
    #bombCount {
      font-size: 18px;
      margin-top: 2px;
    }
    #weaponBtn {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: var(--accent-color);
      color: var(--bg-color);
      font-family: 'Courier New', monospace;
      font-size: 11px;
      font-weight: bold;
      border: 3px solid var(--fg-secondary);
      cursor: pointer;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 100;
    }
    #weaponBtn:active {
      opacity: 0.7;
    }
    #weaponBtn.shot-mode {
      background: var(--accent-color);
    }
    #weaponBtn.laser-mode {
      background: var(--fg-secondary);
    }
    #weaponIcon {
      font-size: 16px;
      margin-bottom: 2px;
    }
    #pauseBtn {
      position: absolute;
      top: 6px;
      right: 6px;
      width: 44px;
      height: 44px;
      border-radius: 8px;
      background: var(--fg-color);
      color: var(--bg-color);
      font-family: 'Courier New', monospace;
      font-size: 18px;
      border: 2px solid var(--accent-color);
      cursor: pointer;
      z-index: 100;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    #pauseBtn.hidden {
      display: none;
    }
    #pauseScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--bg-color);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      font-family: 'Courier New', monospace;
      z-index: 200;
    }
    #pauseScreen h1 {
      font-size: 28px;
      margin-bottom: 30px;
      color: var(--fg-color);
    }
    #pauseScreen .btn {
      margin: 10px;
    }
    #startScreen, #gameOverScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: var(--bg-color);
      font-family: 'Courier New', monospace;
    }
    #startScreen h1, #gameOverScreen h1 {
      font-size: 24px;
      margin-bottom: 20px;
      color: var(--fg-color);
    }
    #startScreen p, #gameOverScreen p {
      font-size: 14px;
      margin-bottom: 10px;
      color: var(--fg-secondary);
    }
    .btn {
      margin-top: 30px;
      padding: 15px 40px;
      font-size: 18px;
      font-family: 'Courier New', monospace;
      background: var(--fg-color);
      color: var(--bg-color);
      border: none;
      cursor: pointer;
    }
    #finalScore {
      font-size: 32px;
      font-weight: bold;
      margin: 20px 0;
      color: var(--fg-color);
    }
    .hidden {
      display: none !important;
    }
    #shipSelectScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: var(--bg-color);
      font-family: 'Courier New', monospace;
    }
    #shipSelectScreen h1 {
      font-size: 22px;
      margin-bottom: 25px;
      color: var(--fg-color);
    }
    .ship-options {
      display: flex;
      flex-direction: column;
      gap: 15px;
      width: 90%;
      max-width: 320px;
    }
    .ship-btn {
      padding: 15px;
      font-size: 14px;
      font-family: 'Courier New', monospace;
      background: var(--bg-color);
      color: var(--fg-color);
      border: 3px solid var(--fg-color);
      cursor: pointer;
      text-align: left;
      transition: all 0.2s;
    }
    .ship-btn:active, .ship-btn.selected {
      background: var(--fg-color);
      color: var(--bg-color);
    }
    .ship-btn .ship-name {
      font-size: 16px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    .ship-btn .ship-desc {
      font-size: 11px;
      opacity: 0.8;
    }
    #shipSelectScreen .btn {
      margin-top: 25px;
    }
    #autoBtn {
      position: absolute;
      top: 10px;
      left: 10px;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: var(--bg-color);
      color: var(--fg-color);
      border: 3px solid var(--fg-color);
      font-family: 'Courier New', monospace;
      font-size: 10px;
      font-weight: bold;
      cursor: pointer;
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      line-height: 1.2;
    }
    #autoBtn.active {
      background: var(--fg-color);
      color: var(--bg-color);
    }
    #autoBtn .auto-icon {
      font-size: 14px;
    }
    #darkModeBtn {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--bg-color);
      color: var(--fg-color);
      border: 2px solid var(--fg-color);
      font-family: 'Courier New', monospace;
      font-size: 18px;
      cursor: pointer;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    #darkModeBtn:active {
      opacity: 0.7;
    }
    /* BGMé¸æŠUIï¼ˆã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ç”¨ï¼‰ */
    .bgm-select {
      margin: 20px 0;
      text-align: center;
    }
    .bgm-label {
      font-size: 12px;
      color: var(--fg-secondary);
      margin-bottom: 10px;
    }
    .bgm-selector {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
    }
    .bgm-arrow {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: var(--bg-color);
      color: var(--fg-color);
      border: 2px solid var(--fg-color);
      font-size: 16px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .bgm-arrow:active {
      background: var(--fg-color);
      color: var(--bg-color);
    }
    .bgm-name {
      min-width: 180px;
      font-size: 14px;
      font-weight: bold;
      color: var(--fg-color);
    }
    /* æˆ»ã‚‹ãƒœã‚¿ãƒ³ */
    .btn-back {
      margin-top: 15px;
      padding: 10px 30px;
      font-size: 14px;
      background: var(--bg-color);
      color: var(--fg-color);
      border: 2px solid var(--fg-color);
    }
    .btn-back:active {
      background: var(--fg-color);
      color: var(--bg-color);
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    <div id="ui">
      <span id="scoreDisplay">SCORE: 0</span>
      <span id="livesDisplay">â™¥â™¥â™¥</span>
    </div>
    
    <button id="bombBtn" class="hidden">
      BOMB
      <span id="bombCount">3</span>
    </button>
    
    <button id="weaponBtn" class="hidden shot-mode">
      <span id="weaponIcon">///</span>
      <span id="weaponLabel">SHOT</span>
    </button>
    
    <button id="pauseBtn" class="hidden">âšâš</button>
    
    <button id="autoBtn" class="hidden">
      <span class="auto-icon">ğŸ¤–</span>
      <span>AUTO</span>
    </button>
    
    <div id="pauseScreen" class="hidden">
      <h1>PAUSE</h1>
      <button class="btn" id="resumeBtn">RESUME</button>
      <button class="btn" id="quitBtn">QUIT</button>
      <button id="darkModeBtn">â˜€</button>
    </div>
    
    <div id="startScreen">
      <h1>å¼¾ å¹• å°„ æ’ƒ</h1>
      <p>â— ç”»é¢ã‚¿ãƒƒãƒã§è‡ªæ©Ÿç§»å‹•</p>
      <p>â— æ•µã‚’å€’ã—ã¦ã‚¹ã‚³ã‚¢ç²å¾—</p>
      <p>â— å¼¾ã«å½“ãŸã‚‹ã¨ãƒ©ã‚¤ãƒ•æ¸›å°‘</p>
      
      <div class="bgm-select">
        <p class="bgm-label">â™ª BGM SELECT â™ª</p>
        <div class="bgm-selector">
          <button class="bgm-arrow" id="bgmPrevBtn">â—€</button>
          <span class="bgm-name" id="bgmNameDisplay">æƒ…å‹•ã‚«ã‚¿ãƒ«ã‚·ã‚¹</span>
          <button class="bgm-arrow" id="bgmNextBtn">â–¶</button>
        </div>
      </div>
      
      <button class="btn" id="startBtn">START</button>
      <button id="darkModeBtn">â˜€</button>
    </div>
    
    <div id="shipSelectScreen" class="hidden">
      <h1>æ©Ÿ ä½“ é¸ æŠ</h1>
      <div class="ship-options">
        <button class="ship-btn" data-ship="shot">
          <div class="ship-name">â–¶ SHOT TYPE</div>
          <div class="ship-desc">ã‚·ãƒ§ãƒƒãƒˆå¼·åŒ–å‹ï¼šåºƒç¯„å›²ã®å¼¾å¹•ã§æ•µã‚’ä¸€æƒ</div>
        </button>
        <button class="ship-btn" data-ship="laser">
          <div class="ship-name">â–¶ LASER TYPE</div>
          <div class="ship-desc">ãƒ¬ãƒ¼ã‚¶ãƒ¼å¼·åŒ–å‹ï¼šè²«é€šãƒ¬ãƒ¼ã‚¶ãƒ¼ã§é«˜ç«åŠ›</div>
        </button>
        <button class="ship-btn" data-ship="bomb">
          <div class="ship-name">â–¶ BOMB TYPE</div>
          <div class="ship-desc">ãƒœãƒ å¢—é‡å‹ï¼šãƒœãƒ 5å€‹ï¼†è¢«å¼¾æ™‚ãƒœãƒ å›å¾©</div>
        </button>
      </div>
      <button class="btn" id="confirmShipBtn">CONFIRM</button>
      <button class="btn btn-back" id="backToTitleBtn">â—€ BACK</button>
      <button id="darkModeBtn">â˜€</button>
    </div>
    
    <div id="gameOverScreen" class="hidden">
      <h1>GAME OVER</h1>
      <p>FINAL SCORE</p>
      <div id="finalScore">0</div>
      <button class="btn" id="restartBtn">RETRY</button>
      <button id="darkModeBtn">â˜€</button>
    </div>
  </div>

  <script>
    // Canvas setup
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // iPhone 14 dimensions (390 x 844 logical pixels)
    const GAME_WIDTH = 390;
    const GAME_HEIGHT = 844;
    
    // Set canvas size
    function resizeCanvas() {
      const ratio = window.devicePixelRatio || 1;
      const containerWidth = window.innerWidth;
      const containerHeight = window.innerHeight;
      
      const scale = Math.min(containerWidth / GAME_WIDTH, containerHeight / GAME_HEIGHT);
      
      canvas.style.width = (GAME_WIDTH * scale) + 'px';
      canvas.style.height = (GAME_HEIGHT * scale) + 'px';
      canvas.width = GAME_WIDTH * ratio;
      canvas.height = GAME_HEIGHT * ratio;
      ctx.scale(ratio, ratio);
    }
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    
    // Game state
    let gameRunning = false;
    let gamePaused = false;
    let gameOverPending = false; // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å¾…æ©Ÿä¸­
    let gameOverTimer = 0;
    const GAME_OVER_DELAY = 90; // ç´„1.5ç§’ã®ãƒ‡ã‚£ãƒ¬ã‚¤
    let score = 0;
    let lives = 3;
    let frameCount = 0;
    let difficulty = 1;
    
    // ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰
    let darkMode = false;
    
    // æç”»è‰²ï¼ˆãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ã§åè»¢ï¼‰
    function getBgColor() { return darkMode ? '#000' : '#fff'; }
    function getFgColor() { return darkMode ? '#fff' : '#000'; }
    function getFgColorRgb() { return darkMode ? '255, 255, 255' : '0, 0, 0'; }
    function getBgColorRgb() { return darkMode ? '0, 0, 0' : '255, 255, 255'; }
    
    function toggleDarkMode() {
      darkMode = !darkMode;
      document.body.classList.toggle('dark-mode', darkMode);
      
      // ãƒœã‚¿ãƒ³ã®ã‚¢ã‚¤ã‚³ãƒ³ã‚’æ›´æ–°
      document.querySelectorAll('#darkModeBtn').forEach(btn => {
        btn.textContent = darkMode ? 'â˜€' : 'â˜¾';
      });
      
      // ã‚­ãƒ£ãƒ³ãƒã‚¹èƒŒæ™¯æ›´æ–°
      canvas.style.background = getBgColor();
    }
    
    // ã‚°ãƒ¬ã‚¤ã‚º
    let grazeCount = 0; // ç´¯è¨ˆã‚°ãƒ¬ã‚¤ã‚ºæ•°
    let grazeCombo = 0; // é€£ç¶šã‚°ãƒ¬ã‚¤ã‚º
    let grazeCooldown = 0; // ã‚°ãƒ¬ã‚¤ã‚ºéŸ³ã®é–“å¼•ãç”¨
    const GRAZE_RADIUS = 25; // ã‚°ãƒ¬ã‚¤ã‚ºåˆ¤å®šåŠå¾„
    const GRAZE_SCORE = 10; // ã‚°ãƒ¬ã‚¤ã‚º1å›ã®ã‚¹ã‚³ã‚¢
    let grazedBullets = new Set(); // ã‚°ãƒ¬ã‚¤ã‚ºæ¸ˆã¿ã®å¼¾ã‚’è¿½è·¡
    
    // ã‚ªãƒ¼ãƒˆãƒ‘ã‚¤ãƒ­ãƒƒãƒˆ
    let autoPilot = false;
    let autoTargetX = GAME_WIDTH / 2;
    let autoTargetY = GAME_HEIGHT - 200;
    let autoVelocityX = 0;
    let autoVelocityY = 0;
    
    // ã‚ªãƒ¼ãƒˆãƒ‘ã‚¤ãƒ­ãƒƒãƒˆAI
    function runAutoPilot() {
      if (!autoPilot || gameOverPending) return;
      
      const safetyMargin = 35;
      
      // å¼¾ã®è»Œé“ã‚’é•·æœŸäºˆæ¸¬ã—ã¦å±é™ºã‚¨ãƒªã‚¢ã‚’è¨ˆç®—
      let dangerField = [];
      
      // æ•µå¼¾ã®è»Œé“äºˆæ¸¬ï¼ˆé•·ã‚ã«äºˆæ¸¬ï¼‰
      for (const b of enemyBullets) {
        const speed = Math.sqrt(b.vx * b.vx + b.vy * b.vy);
        if (speed < 0.1) continue;
        
        // 30ãƒ•ãƒ¬ãƒ¼ãƒ å…ˆã¾ã§äºˆæ¸¬
        for (let t = 1; t <= 30; t++) {
          const futureX = b.x + b.vx * t;
          const futureY = b.y + b.vy * t;
          
          // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®è¡Œå‹•ç¯„å›²å†…ã®ã¿
          if (futureY > 80 && futureY < GAME_HEIGHT - 120) {
            // æ™‚é–“ã«å¿œã˜ãŸå±é™ºåº¦ã®é‡ã¿ï¼ˆè¿‘ã„æœªæ¥ã»ã©å±é™ºï¼‰
            const timeWeight = Math.max(0, 1 - t / 35);
            dangerField.push({
              x: futureX,
              y: futureY,
              radius: b.radius + safetyMargin,
              weight: timeWeight * 2,
              time: t
            });
          }
        }
      }
      
      // ãƒ¬ãƒ¼ã‚¶ãƒ¼ã®å±é™ºã‚¨ãƒªã‚¢ï¼ˆç™ºå°„äºˆæ¸¬ã‚’å«ã‚€ï¼‰
      for (const laser of lasers) {
        const laserWidth = laser.width * 5 + safetyMargin;
        let weight = 1;
        
        if (laser.phase === 'firing') {
          weight = 5; // ç™ºå°„ä¸­ã¯æœ€ã‚‚å±é™º
        } else if (laser.phase === 'warning') {
          // è­¦å‘Šã®é€²è¡Œåº¦ã«å¿œã˜ã¦å±é™ºåº¦ä¸Šæ˜‡
          weight = 1 + (laser.frame / laser.warningDuration) * 4;
        }
        
        for (let y = 100; y < GAME_HEIGHT - 120; y += 40) {
          dangerField.push({
            x: laser.targetX,
            y: y,
            radius: laserWidth,
            weight: weight,
            time: 0,
            isLaser: true
          });
        }
      }
      
      // ãƒœã‚¹/ä¸­ãƒœã‚¹ã®ãƒ¬ãƒ¼ã‚¶ãƒ¼ç™ºå°„äºˆæ¸¬
      for (const e of enemies) {
        if ((e.isBoss || e.isMiniboss) && !e.entryPhase) {
          // ãƒ¬ãƒ¼ã‚¶ãƒ¼ç™ºå°„ãŒè¿‘ã„å ´åˆã€äºˆæ¸¬å±é™ºã‚¨ãƒªã‚¢ã‚’è¿½åŠ 
          const timeToLaser = e.laserInterval - e.laserCooldown;
          if (timeToLaser < 90 && timeToLaser > 0) { // 1.5ç§’ä»¥å†…
            const predictWeight = (90 - timeToLaser) / 90 * 2;
            
            // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç¾åœ¨ä½ç½®å‘¨è¾ºã‚’å±é™ºã‚¨ãƒªã‚¢ã«ï¼ˆç‹™ã‚ã‚Œã‚‹å¯èƒ½æ€§ï¼‰
            for (let offsetX = -60; offsetX <= 60; offsetX += 30) {
              dangerField.push({
                x: player.x + offsetX,
                y: player.y,
                radius: 50,
                weight: predictWeight,
                time: timeToLaser,
                isLaserPredict: true
              });
            }
          }
        }
      }
      
      // æŒ‡å®šä½ç½®ã®å±é™ºåº¦ã‚’è©•ä¾¡ï¼ˆæ»‘ã‚‰ã‹ãªå‹¾é…ï¼‰
      function evaluateDanger(x, y) {
        let danger = 0;
        for (const d of dangerField) {
          const dist = Math.sqrt((x - d.x) ** 2 + (y - d.y) ** 2);
          if (dist < d.radius * 2) {
            // è·é›¢ã«å¿œã˜ãŸæ»‘ã‚‰ã‹ãªå±é™ºåº¦å‹¾é…
            const proximity = Math.max(0, 1 - dist / (d.radius * 2));
            let multiplier = 100;
            if (d.isLaser) multiplier = 200; // ãƒ¬ãƒ¼ã‚¶ãƒ¼ã¯ã‚ˆã‚Šå±é™º
            danger += proximity * proximity * d.weight * multiplier;
          }
        }
        return danger;
      }
      
      // ç·Šæ€¥å›é¿ãŒå¿…è¦ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆç›´è¿‘ã®å¼¾ã¨ã®è·é›¢ï¼‰
      let emergencyEscape = false;
      let escapeDirection = { x: 0, y: 0 };
      
      for (const b of enemyBullets) {
        // 3ãƒ•ãƒ¬ãƒ¼ãƒ å¾Œã®å¼¾ä½ç½®
        const futureX = b.x + b.vx * 3;
        const futureY = b.y + b.vy * 3;
        const dist = Math.sqrt((futureX - player.x) ** 2 + (futureY - player.y) ** 2);
        
        if (dist < b.radius + player.hitboxRadius + 15) {
          emergencyEscape = true;
          // å¼¾ã‹ã‚‰é€ƒã’ã‚‹æ–¹å‘ã‚’è¨ˆç®—
          const dx = player.x - futureX;
          const dy = player.y - futureY;
          const d = Math.sqrt(dx * dx + dy * dy) || 1;
          escapeDirection.x += dx / d;
          escapeDirection.y += dy / d;
        }
      }
      
      // ãƒ¬ãƒ¼ã‚¶ãƒ¼ç™ºå°„ä¸­ã®ç·Šæ€¥å›é¿
      for (const laser of lasers) {
        if (laser.phase === 'firing') {
          const laserDist = Math.abs(player.x - laser.targetX);
          if (laserDist < laser.width * 4 + 20) {
            emergencyEscape = true;
            escapeDirection.x += (player.x > laser.targetX) ? 1 : -1;
          }
        }
      }
      
      // ç·Šæ€¥å›é¿ãƒ¢ãƒ¼ãƒ‰
      if (emergencyEscape) {
        const escapeMag = Math.sqrt(escapeDirection.x ** 2 + escapeDirection.y ** 2) || 1;
        const escapeX = player.x + (escapeDirection.x / escapeMag) * 25;
        const escapeY = player.y + (escapeDirection.y / escapeMag) * 15;
        
        // ç·Šæ€¥å›é¿ã¯å³åº§ã«ç§»å‹•
        autoTargetX = Math.max(25, Math.min(GAME_WIDTH - 25, escapeX));
        autoTargetY = Math.max(100, Math.min(GAME_HEIGHT - 160, escapeY));
        player.targetX = autoTargetX;
        player.targetY = autoTargetY;
        
        // ç·Šæ€¥ãƒœãƒ åˆ¤å®š
        const nearbyBullets = enemyBullets.filter(b => {
          const d = Math.sqrt((b.x - player.x) ** 2 + (b.y - player.y) ** 2);
          return d < 40;
        }).length;
        
        if (nearbyBullets >= 3 && player.bombs > 0 && !bombEffect.active) {
          useBomb();
        }
        
        return;
      }
      
      // ç›®æ¨™ä½ç½®ã‚’è¨ˆç®—
      let goalX = GAME_WIDTH / 2;
      let goalY = GAME_HEIGHT - 200;
      let goalPriority = 0;
      
      // 1. ã‚¢ã‚¤ãƒ†ãƒ å›åç›®æ¨™
      for (const item of items) {
        let value = 80;
        if (item.type === 'life') value = 250;
        else if (item.type === 'bomb') value = 180;
        else if (item.type === 'power' && player.power < 9) value = 120;
        
        // ã‚¢ã‚¤ãƒ†ãƒ ãŒä¸‹ã«è¿‘ã„ã»ã©ç·Šæ€¥
        const urgency = (item.y / GAME_HEIGHT) * 100;
        const dist = Math.sqrt((item.x - player.x) ** 2 + (item.y - player.y) ** 2);
        const danger = evaluateDanger(item.x, Math.min(item.y + 40, GAME_HEIGHT - 160));
        
        const priority = value + urgency - dist * 0.3 - danger * 0.02;
        
        if (priority > goalPriority && danger < 500) {
          goalPriority = priority;
          goalX = item.x;
          goalY = Math.min(item.y + 40, GAME_HEIGHT - 160);
        }
      }
      
      // 2. æ•µæ”»æ’ƒç›®æ¨™
      const hasBossOrMiniboss = enemies.some(e => e.isBoss || e.isMiniboss);
      
      if (!hasBossOrMiniboss) {
        // é€šå¸¸æ•µã‚’ç‹™ã†
        for (const e of enemies) {
          if (e.isBoss || e.isMiniboss) continue;
          
          const targetY = Math.max(e.y + 80, GAME_HEIGHT - 220);
          const danger = evaluateDanger(e.x, targetY);
          const urgency = (e.y / 250) * 60;
          const dist = Math.abs(e.x - player.x);
          
          const priority = 70 + urgency - dist * 0.2 - danger * 0.015;
          
          if (priority > goalPriority && danger < 400) {
            goalPriority = priority;
            goalX = e.x;
            goalY = targetY;
          }
        }
      } else {
        // ãƒœã‚¹/ä¸­ãƒœã‚¹ã‚’ç‹™ã†
        const boss = enemies.find(e => e.isBoss || e.isMiniboss);
        if (boss && !boss.entryPhase) {
          const targetY = GAME_HEIGHT - 200;
          const danger = evaluateDanger(boss.x, targetY);
          
          if (danger < 300) {
            const priority = 60 - danger * 0.01;
            if (priority > goalPriority) {
              goalPriority = priority;
              goalX = boss.x;
              goalY = targetY;
            }
          }
        }
      }
      
      // ç¾åœ¨ä½ç½®ã¨ç›®æ¨™ã®å±é™ºåº¦ã‚’è©•ä¾¡
      const currentDanger = evaluateDanger(player.x, player.y);
      const goalDanger = evaluateDanger(goalX, goalY);
      
      // å®‰å…¨ãªçµŒè·¯ã‚’æ¢ã™ï¼ˆç›®æ¨™ã«å‘ã‹ã„ã¤ã¤å±é™ºã‚’é¿ã‘ã‚‹ï¼‰
      let bestX = goalX;
      let bestY = goalY;
      let bestScore = -Infinity;
      
      // ç›®æ¨™æ–¹å‘ã‚’ä¸­å¿ƒã«æ¢ç´¢
      const dirToGoalX = goalX - player.x;
      const dirToGoalY = goalY - player.y;
      const distToGoal = Math.sqrt(dirToGoalX * dirToGoalX + dirToGoalY * dirToGoalY);
      
      // æ¢ç´¢ç¯„å›²ï¼ˆç¾åœ¨ã®é€Ÿåº¦æ–¹å‘ã‚’è€ƒæ…®ï¼‰
      for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
        for (let dist = 30; dist <= 100; dist += 35) {
          const testX = Math.max(25, Math.min(GAME_WIDTH - 25, player.x + Math.cos(angle) * dist));
          const testY = Math.max(100, Math.min(GAME_HEIGHT - 160, player.y + Math.sin(angle) * dist));
          
          let score = 0;
          
          // å±é™ºåº¦ã‚’æ¸›ç‚¹
          const danger = evaluateDanger(testX, testY);
          score -= danger * 1.5;
          
          // ç›®æ¨™ã¸ã®è¿‘ã•ã«ãƒœãƒ¼ãƒŠã‚¹
          const distToGoalFromTest = Math.sqrt((testX - goalX) ** 2 + (testY - goalY) ** 2);
          score -= distToGoalFromTest * 0.5;
          
          // ç¾åœ¨ã®ç§»å‹•æ–¹å‘ã¨ã®ä¸€è²«æ€§ï¼ˆæ€¥ãªæ–¹å‘è»¢æ›ã‚’é¿ã‘ã‚‹ï¼‰
          const moveX = testX - player.x;
          const moveY = testY - player.y;
          const moveDist = Math.sqrt(moveX * moveX + moveY * moveY);
          if (moveDist > 0.1 && (autoVelocityX !== 0 || autoVelocityY !== 0)) {
            const velMag = Math.sqrt(autoVelocityX * autoVelocityX + autoVelocityY * autoVelocityY);
            if (velMag > 0.1) {
              const dot = (moveX * autoVelocityX + moveY * autoVelocityY) / (moveDist * velMag);
              score += dot * 30; // åŒã˜æ–¹å‘ã«é€²ã‚€ã¨ãƒœãƒ¼ãƒŠã‚¹
            }
          }
          
          // ä¸­å¤®ä»˜è¿‘ãƒœãƒ¼ãƒŠã‚¹
          score -= Math.abs(testX - GAME_WIDTH / 2) * 0.1;
          
          // ç”»é¢ä¸‹éƒ¨ãƒœãƒ¼ãƒŠã‚¹
          if (testY > GAME_HEIGHT - 250) score += 10;
          
          if (score > bestScore) {
            bestScore = score;
            bestX = testX;
            bestY = testY;
          }
        }
      }
      
      // å±é™ºãŒé«˜ã„å ´åˆã¯å®‰å…¨ä½ç½®å„ªå…ˆã€ãã†ã§ãªã‘ã‚Œã°ç›®æ¨™ã¸
      let finalTargetX, finalTargetY;
      
      if (currentDanger > 200) {
        // å±é™ºå›é¿ãƒ¢ãƒ¼ãƒ‰
        finalTargetX = bestX;
        finalTargetY = bestY;
      } else if (goalDanger < 150) {
        // ç›®æ¨™ãŒå®‰å…¨ãªã‚‰ç›´æ¥å‘ã‹ã†
        finalTargetX = goalX;
        finalTargetY = goalY;
      } else {
        // å®‰å…¨çµŒè·¯ã§ç›®æ¨™ã¸
        finalTargetX = bestX;
        finalTargetY = bestY;
      }
      
      // æ»‘ã‚‰ã‹ãªç§»å‹•ï¼ˆåŠ é€Ÿåº¦ãƒ™ãƒ¼ã‚¹ã®ç§»å‹•ï¼‰
      const maxAccel = 1.2;
      const maxSpeed = 8;
      const damping = 0.85;
      
      // ç›®æ¨™ã¸ã®æ–¹å‘
      const dx = finalTargetX - autoTargetX;
      const dy = finalTargetY - autoTargetY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > 1) {
        // åŠ é€Ÿåº¦ã‚’è¨ˆç®—
        let accelX = (dx / dist) * maxAccel;
        let accelY = (dy / dist) * maxAccel;
        
        // è·é›¢ãŒè¿‘ã„å ´åˆã¯æ¸›é€Ÿ
        if (dist < 50) {
          const slowFactor = dist / 50;
          accelX *= slowFactor;
          accelY *= slowFactor;
        }
        
        // é€Ÿåº¦ã‚’æ›´æ–°
        autoVelocityX += accelX;
        autoVelocityY += accelY;
      }
      
      // æ¸›è¡°ã‚’é©ç”¨
      autoVelocityX *= damping;
      autoVelocityY *= damping;
      
      // é€Ÿåº¦åˆ¶é™
      const speed = Math.sqrt(autoVelocityX * autoVelocityX + autoVelocityY * autoVelocityY);
      if (speed > maxSpeed) {
        autoVelocityX = (autoVelocityX / speed) * maxSpeed;
        autoVelocityY = (autoVelocityY / speed) * maxSpeed;
      }
      
      // ç›®æ¨™ä½ç½®ã‚’æ›´æ–°
      autoTargetX += autoVelocityX;
      autoTargetY += autoVelocityY;
      
      // ç¯„å›²åˆ¶é™
      autoTargetX = Math.max(20, Math.min(GAME_WIDTH - 20, autoTargetX));
      autoTargetY = Math.max(100, Math.min(GAME_HEIGHT - 160, autoTargetY));
      
      // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç›®æ¨™ä½ç½®ã‚’è¨­å®š
      player.targetX = autoTargetX;
      player.targetY = autoTargetY;
      
      // æ­¦å™¨ã®è‡ªå‹•åˆ‡ã‚Šæ›¿ãˆ
      if (hasBossOrMiniboss) {
        if (player.shipType === 'laser' && player.weaponMode === 'shot') {
          toggleWeapon();
        }
      } else {
        if (player.weaponMode === 'laser') {
          toggleWeapon();
        }
      }
    }
    
    // Audio Context for sound effects
    let audioCtx = null;
    
    function initAudio() {
      if (!audioCtx) {
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      }
      if (audioCtx.state === 'suspended') {
        audioCtx.resume();
      }
    }
    
    // ========== BGMã‚·ã‚¹ãƒ†ãƒ  ==========
    let bgmPlaying = false;
    let bgmAudio = null;
    let currentBgmTrack = 0;
    const BGM_VOLUME = 0.5;
    
    // BGMãƒˆãƒ©ãƒƒã‚¯å®šç¾©ï¼ˆMP3ãƒ•ã‚¡ã‚¤ãƒ«ï¼‰
    const BGM_TRACKS = [
      { name: 'æƒ…å‹•ã‚«ã‚¿ãƒ«ã‚·ã‚¹', file: 'æƒ…å‹•ã‚«ã‚¿ãƒ«ã‚·ã‚¹.mp3' },
      { name: 'Will you still cry?', file: 'Will_you_still_cry.mp3' },
      { name: 'æˆ¦ã„ã®æ—…è·¯ã‚’å¾ã', file: 'æˆ¦ã„ã®æ—…è·¯ã‚’å¾ã.mp3' }
    ];
    
    function startBGM(trackIndex = 0) {
      stopBGM();
      
      currentBgmTrack = trackIndex;
      bgmPlaying = true;
      
      const track = BGM_TRACKS[trackIndex];
      bgmAudio = new Audio(track.file);
      bgmAudio.volume = BGM_VOLUME;
      bgmAudio.loop = true;
      
      // å†ç”Ÿé–‹å§‹
      bgmAudio.play().catch(e => {
        console.log('BGM autoplay blocked:', e);
      });
    }
    
    function stopBGM() {
      bgmPlaying = false;
      if (bgmAudio) {
        bgmAudio.pause();
        bgmAudio.currentTime = 0;
        bgmAudio = null;
      }
    }
    
    function nextBGM() {
      currentBgmTrack = (currentBgmTrack + 1) % BGM_TRACKS.length;
      startBGM(currentBgmTrack);
    }
    // ========== BGMã‚·ã‚¹ãƒ†ãƒ çµ‚äº† ==========
    
    // åŠ¹æœéŸ³ç”Ÿæˆé–¢æ•°ï¼ˆæ€’é¦–é ˜èœ‚å¤§å¾€ç”Ÿé¢¨ï¼‰
    function playSound(type) {
      if (!audioCtx) return;
      
      const now = audioCtx.currentTime;
      
      switch(type) {
        case 'shot': {
          // æ€’é¦–é ˜èœ‚é¢¨ã‚·ãƒ§ãƒƒãƒˆéŸ³ï¼ˆé‹­ã„ã‚¢ã‚¿ãƒƒã‚¯ã€ãƒ‘ã‚­ãƒ‘ã‚­ã—ãŸéŸ³ï¼‰
          const osc = audioCtx.createOscillator();
          const osc2 = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          const filter = audioCtx.createBiquadFilter();
          
          osc.connect(filter);
          osc2.connect(filter);
          filter.connect(gain);
          gain.connect(audioCtx.destination);
          
          filter.type = 'highpass';
          filter.frequency.setValueAtTime(2000, now);
          filter.frequency.exponentialRampToValueAtTime(800, now + 0.02);
          
          osc.frequency.setValueAtTime(2400, now);
          osc.frequency.exponentialRampToValueAtTime(600, now + 0.025);
          osc.type = 'square';
          
          osc2.frequency.setValueAtTime(1800, now);
          osc2.frequency.exponentialRampToValueAtTime(400, now + 0.02);
          osc2.type = 'sawtooth';
          
          gain.gain.setValueAtTime(0.18, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
          
          osc.start(now);
          osc.stop(now + 0.03);
          osc2.start(now);
          osc2.stop(now + 0.03);
          break;
        }
        case 'laser': {
          // ãƒ¬ãƒ¼ã‚¶ãƒ¼éŸ³ï¼ˆã‚¸ã‚¸ã‚¸ã¨ã„ã†é›»æ’ƒæ„Ÿï¼‰
          const osc = audioCtx.createOscillator();
          const osc2 = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          const filter = audioCtx.createBiquadFilter();
          
          osc.connect(filter);
          osc2.connect(filter);
          filter.connect(gain);
          gain.connect(audioCtx.destination);
          
          filter.type = 'bandpass';
          filter.frequency.setValueAtTime(3000, now);
          filter.Q.setValueAtTime(8, now);
          
          osc.frequency.setValueAtTime(120 + Math.random() * 30, now);
          osc.type = 'sawtooth';
          osc2.frequency.setValueAtTime(123, now);
          osc2.type = 'square';
          
          gain.gain.setValueAtTime(0.07, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
          
          osc.start(now);
          osc.stop(now + 0.06);
          osc2.start(now);
          osc2.stop(now + 0.06);
          break;
        }
        case 'homing': {
          // ã‚ªãƒ—ã‚·ãƒ§ãƒ³/ãƒ›ãƒ¼ãƒŸãƒ³ã‚°ç™ºå°„éŸ³ï¼ˆã‚­ãƒ¥ã‚¤ãƒ³ï¼‰
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          const filter = audioCtx.createBiquadFilter();
          
          osc.connect(filter);
          filter.connect(gain);
          gain.connect(audioCtx.destination);
          
          filter.type = 'bandpass';
          filter.frequency.setValueAtTime(2500, now);
          filter.frequency.exponentialRampToValueAtTime(4000, now + 0.08);
          filter.Q.setValueAtTime(5, now);
          
          osc.frequency.setValueAtTime(800, now);
          osc.frequency.exponentialRampToValueAtTime(2000, now + 0.06);
          osc.frequency.exponentialRampToValueAtTime(1200, now + 0.1);
          osc.type = 'sine';
          
          gain.gain.setValueAtTime(0.12, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
          
          osc.start(now);
          osc.stop(now + 0.1);
          break;
        }
        case 'enemyHit': {
          // é‡‘å±ã¸ã®ãƒ’ãƒƒãƒˆéŸ³
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          osc.frequency.setValueAtTime(800, now);
          osc.frequency.exponentialRampToValueAtTime(200, now + 0.05);
          osc.type = 'triangle';
          gain.gain.setValueAtTime(0.12, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
          osc.start(now);
          osc.stop(now + 0.05);
          break;
        }
        case 'enemyDestroy': {
          // æ•µç ´å£ŠéŸ³ï¼ˆãƒ‰ã‚«ãƒƒï¼é‹­ã„çˆ†ç™ºï¼‰
          const noise = createNoise();
          const osc = audioCtx.createOscillator();
          const osc2 = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          const noiseGain = audioCtx.createGain();
          const filter = audioCtx.createBiquadFilter();
          const filter2 = audioCtx.createBiquadFilter();
          
          noise.connect(filter);
          filter.connect(noiseGain);
          osc.connect(filter2);
          osc2.connect(gain);
          filter2.connect(gain);
          noiseGain.connect(audioCtx.destination);
          gain.connect(audioCtx.destination);
          
          filter.type = 'bandpass';
          filter.frequency.setValueAtTime(4000, now);
          filter.frequency.exponentialRampToValueAtTime(500, now + 0.08);
          filter.Q.setValueAtTime(2, now);
          
          filter2.type = 'lowpass';
          filter2.frequency.setValueAtTime(1000, now);
          
          osc.frequency.setValueAtTime(300, now);
          osc.frequency.exponentialRampToValueAtTime(80, now + 0.06);
          osc.type = 'square';
          
          osc2.frequency.setValueAtTime(150, now);
          osc2.frequency.exponentialRampToValueAtTime(40, now + 0.08);
          osc2.type = 'sine';
          
          gain.gain.setValueAtTime(0.22, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
          noiseGain.gain.setValueAtTime(0.18, now);
          noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
          
          osc.start(now);
          osc.stop(now + 0.08);
          osc2.start(now);
          osc2.stop(now + 0.1);
          noise.start(now);
          noise.stop(now + 0.08);
          break;
        }
        case 'bossDestroy': {
          // ãƒœã‚¹ç ´å£Šï¼ˆãƒ‰ãƒ‰ãƒ‰ãƒ‰ã‚«ãƒ¼ãƒ³ï¼é€£ç¶šçˆ†ç™ºï¼‰
          for (let i = 0; i < 5; i++) {
            const delay = i * 0.07;
            const noise = createNoise();
            const osc = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const noiseGain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            
            noise.connect(filter);
            filter.connect(noiseGain);
            osc.connect(gain);
            osc2.connect(gain);
            noiseGain.connect(audioCtx.destination);
            gain.connect(audioCtx.destination);
            
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(5000 - i * 800, now + delay);
            filter.frequency.exponentialRampToValueAtTime(200, now + delay + 0.15);
            filter.Q.setValueAtTime(1, now + delay);
            
            osc.frequency.setValueAtTime(200 - i * 25, now + delay);
            osc.frequency.exponentialRampToValueAtTime(30, now + delay + 0.2);
            osc.type = 'sawtooth';
            
            osc2.frequency.setValueAtTime(100 - i * 10, now + delay);
            osc2.frequency.exponentialRampToValueAtTime(20, now + delay + 0.25);
            osc2.type = 'sine';
            
            const vol = 0.28 - i * 0.02;
            gain.gain.setValueAtTime(vol, now + delay);
            gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.25);
            noiseGain.gain.setValueAtTime(vol * 0.8, now + delay);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.18);
            
            osc.start(now + delay);
            osc.stop(now + delay + 0.25);
            osc2.start(now + delay);
            osc2.stop(now + delay + 0.25);
            noise.start(now + delay);
            noise.stop(now + delay + 0.18);
          }
          break;
        }
        case 'playerHit': {
          // è¢«å¼¾éŸ³ï¼ˆã‚¬ã‚­ãƒ³ï¼é‡‘å±çš„è¡æ’ƒï¼‰
          const noise = createNoise();
          const osc = audioCtx.createOscillator();
          const osc2 = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          const noiseGain = audioCtx.createGain();
          const filter = audioCtx.createBiquadFilter();
          
          noise.connect(filter);
          filter.connect(noiseGain);
          osc.connect(gain);
          osc2.connect(gain);
          noiseGain.connect(audioCtx.destination);
          gain.connect(audioCtx.destination);
          
          filter.type = 'highpass';
          filter.frequency.setValueAtTime(3000, now);
          filter.frequency.exponentialRampToValueAtTime(500, now + 0.1);
          
          osc.frequency.setValueAtTime(800, now);
          osc.frequency.exponentialRampToValueAtTime(100, now + 0.12);
          osc.type = 'square';
          
          osc2.frequency.setValueAtTime(400, now);
          osc2.frequency.exponentialRampToValueAtTime(50, now + 0.15);
          osc2.type = 'sawtooth';
          
          gain.gain.setValueAtTime(0.3, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
          noiseGain.gain.setValueAtTime(0.25, now);
          noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
          
          osc.start(now);
          osc.stop(now + 0.15);
          osc2.start(now);
          osc2.stop(now + 0.15);
          noise.start(now);
          noise.stop(now + 0.1);
          break;
        }
        case 'playerDeath': {
          // è‡ªæ©Ÿç ´å£Šï¼ˆãƒ‰ãƒƒã‚«ãƒ¼ãƒ³ï¼æ´¾æ‰‹ãªé€£ç¶šçˆ†ç™ºï¼‰
          for (let i = 0; i < 8; i++) {
            const delay = i * 0.05;
            const noise = createNoise();
            const osc = audioCtx.createOscillator();
            const osc2 = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const noiseGain = audioCtx.createGain();
            const filter = audioCtx.createBiquadFilter();
            
            noise.connect(filter);
            filter.connect(noiseGain);
            osc.connect(gain);
            osc2.connect(gain);
            noiseGain.connect(audioCtx.destination);
            gain.connect(audioCtx.destination);
            
            filter.type = 'bandpass';
            filter.frequency.setValueAtTime(6000 - i * 500, now + delay);
            filter.frequency.exponentialRampToValueAtTime(100, now + delay + 0.2);
            filter.Q.setValueAtTime(1, now + delay);
            
            osc.frequency.setValueAtTime(250 - i * 20, now + delay);
            osc.frequency.exponentialRampToValueAtTime(25, now + delay + 0.3);
            osc.type = 'sawtooth';
            
            osc2.frequency.setValueAtTime(120 - i * 10, now + delay);
            osc2.frequency.exponentialRampToValueAtTime(15, now + delay + 0.35);
            osc2.type = 'sine';
            
            const vol = 0.35 - i * 0.025;
            gain.gain.setValueAtTime(vol, now + delay);
            gain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.35);
            noiseGain.gain.setValueAtTime(vol * 0.9, now + delay);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, now + delay + 0.25);
            
            osc.start(now + delay);
            osc.stop(now + delay + 0.35);
            osc2.start(now + delay);
            osc2.stop(now + delay + 0.35);
            noise.start(now + delay);
            noise.stop(now + delay + 0.25);
          }
          break;
        }
        case 'bomb': {
          // ãƒœãƒ /ãƒã‚¤ãƒ‘ãƒ¼ï¼ˆãƒ‰ã‚´ã‚©ã‚©ã‚©ãƒ³ï¼ï¼‹é«˜éŸ³ã®åºƒãŒã‚Šï¼‰
          const noise = createNoise();
          const osc = audioCtx.createOscillator();
          const osc2 = audioCtx.createOscillator();
          const osc3 = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          const noiseGain = audioCtx.createGain();
          const filter = audioCtx.createBiquadFilter();
          const filter2 = audioCtx.createBiquadFilter();
          
          noise.connect(filter);
          filter.connect(noiseGain);
          osc.connect(gain);
          osc2.connect(gain);
          osc3.connect(filter2);
          filter2.connect(gain);
          noiseGain.connect(audioCtx.destination);
          gain.connect(audioCtx.destination);
          
          filter.type = 'lowpass';
          filter.frequency.setValueAtTime(10000, now);
          filter.frequency.exponentialRampToValueAtTime(50, now + 0.6);
          
          filter2.type = 'highpass';
          filter2.frequency.setValueAtTime(2000, now);
          
          osc.frequency.setValueAtTime(80, now);
          osc.frequency.exponentialRampToValueAtTime(20, now + 0.5);
          osc.type = 'sine';
          
          osc2.frequency.setValueAtTime(60, now);
          osc2.frequency.exponentialRampToValueAtTime(15, now + 0.6);
          osc2.type = 'sawtooth';
          
          osc3.frequency.setValueAtTime(2000, now);
          osc3.frequency.exponentialRampToValueAtTime(500, now + 0.3);
          osc3.type = 'sine';
          
          gain.gain.setValueAtTime(0.4, now);
          gain.gain.linearRampToValueAtTime(0.45, now + 0.08);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.7);
          noiseGain.gain.setValueAtTime(0.35, now);
          noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
          
          osc.start(now);
          osc.stop(now + 0.5);
          osc2.start(now);
          osc2.stop(now + 0.6);
          osc3.start(now);
          osc3.stop(now + 0.3);
          noise.start(now);
          noise.stop(now + 0.5);
          break;
        }
        case 'powerup': {
          // ã‚¢ã‚¤ãƒ†ãƒ å–å¾—ï¼ˆã‚·ãƒ£ã‚­ãƒ¼ãƒ³ï¼ï¼‰
          const osc = audioCtx.createOscillator();
          const osc2 = audioCtx.createOscillator();
          const osc3 = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          
          osc.connect(gain);
          osc2.connect(gain);
          osc3.connect(gain);
          gain.connect(audioCtx.destination);
          
          osc.frequency.setValueAtTime(1200, now);
          osc.frequency.setValueAtTime(1800, now + 0.05);
          osc.frequency.setValueAtTime(2400, now + 0.1);
          osc.type = 'sine';
          
          osc2.frequency.setValueAtTime(1205, now);
          osc2.frequency.setValueAtTime(1805, now + 0.05);
          osc2.frequency.setValueAtTime(2405, now + 0.1);
          osc2.type = 'sine';
          
          osc3.frequency.setValueAtTime(600, now);
          osc3.frequency.setValueAtTime(900, now + 0.05);
          osc3.frequency.setValueAtTime(1200, now + 0.1);
          osc3.type = 'triangle';
          
          gain.gain.setValueAtTime(0.15, now);
          gain.gain.setValueAtTime(0.18, now + 0.05);
          gain.gain.setValueAtTime(0.2, now + 0.1);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
          
          osc.start(now);
          osc.stop(now + 0.25);
          osc2.start(now);
          osc2.stop(now + 0.25);
          osc3.start(now);
          osc3.stop(now + 0.25);
          break;
        }
        case 'weaponSwitch': {
          // æ­¦å™¨åˆ‡ã‚Šæ›¿ãˆï¼ˆã‚«ã‚·ãƒ£ãƒƒï¼‰
          const osc = audioCtx.createOscillator();
          const noise = createNoise();
          const gain = audioCtx.createGain();
          const noiseGain = audioCtx.createGain();
          const filter = audioCtx.createBiquadFilter();
          
          osc.connect(gain);
          noise.connect(filter);
          filter.connect(noiseGain);
          gain.connect(audioCtx.destination);
          noiseGain.connect(audioCtx.destination);
          
          filter.type = 'highpass';
          filter.frequency.setValueAtTime(5000, now);
          filter.frequency.exponentialRampToValueAtTime(2000, now + 0.04);
          
          osc.frequency.setValueAtTime(1500, now);
          osc.frequency.setValueAtTime(800, now + 0.02);
          osc.type = 'square';
          
          gain.gain.setValueAtTime(0.12, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
          noiseGain.gain.setValueAtTime(0.1, now);
          noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
          
          osc.start(now);
          osc.stop(now + 0.05);
          noise.start(now);
          noise.stop(now + 0.04);
          break;
        }
        case 'laserWarning': {
          // ãƒ¬ãƒ¼ã‚¶ãƒ¼è­¦å‘Šï¼ˆãƒ”ãƒ”ãƒ”ãƒƒï¼é‹­ã„ã‚¢ãƒ©ãƒ¼ãƒˆï¼‰
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          
          osc.frequency.setValueAtTime(2800, now);
          osc.type = 'square';
          
          gain.gain.setValueAtTime(0.15, now);
          gain.gain.setValueAtTime(0, now + 0.04);
          gain.gain.setValueAtTime(0.15, now + 0.08);
          gain.gain.setValueAtTime(0, now + 0.12);
          gain.gain.setValueAtTime(0.18, now + 0.16);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
          
          osc.start(now);
          osc.stop(now + 0.25);
          break;
        }
        case 'laserFire': {
          // æ•µãƒ¬ãƒ¼ã‚¶ãƒ¼ç™ºå°„ï¼ˆãƒ“ã‚£ã‚£ã‚£ãƒ³ï¼ï¼‰
          const noise = createNoise();
          const osc = audioCtx.createOscillator();
          const osc2 = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          const noiseGain = audioCtx.createGain();
          const filter = audioCtx.createBiquadFilter();
          
          noise.connect(filter);
          filter.connect(noiseGain);
          osc.connect(gain);
          osc2.connect(gain);
          noiseGain.connect(audioCtx.destination);
          gain.connect(audioCtx.destination);
          
          filter.type = 'bandpass';
          filter.frequency.setValueAtTime(2000, now);
          filter.frequency.exponentialRampToValueAtTime(300, now + 0.3);
          filter.Q.setValueAtTime(5, now);
          
          osc.frequency.setValueAtTime(400, now);
          osc.frequency.linearRampToValueAtTime(100, now + 0.25);
          osc.type = 'sawtooth';
          
          osc2.frequency.setValueAtTime(402, now);
          osc2.frequency.linearRampToValueAtTime(102, now + 0.25);
          osc2.type = 'square';
          
          gain.gain.setValueAtTime(0.22, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
          noiseGain.gain.setValueAtTime(0.15, now);
          noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
          
          osc.start(now);
          osc.stop(now + 0.3);
          osc2.start(now);
          osc2.stop(now + 0.3);
          noise.start(now);
          noise.stop(now + 0.25);
          break;
        }
        case 'graze': {
          // ã‚°ãƒ¬ã‚¤ã‚ºéŸ³ï¼ˆã‚·ãƒ£ãƒªãƒƒï¼é«˜éŸ³ã®ã‹ã™ã‚ŠéŸ³ï¼‰
          const noise = createNoise();
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          const noiseGain = audioCtx.createGain();
          const filter = audioCtx.createBiquadFilter();
          const filter2 = audioCtx.createBiquadFilter();
          
          noise.connect(filter);
          filter.connect(filter2);
          filter2.connect(noiseGain);
          osc.connect(gain);
          noiseGain.connect(audioCtx.destination);
          gain.connect(audioCtx.destination);
          
          filter.type = 'highpass';
          filter.frequency.setValueAtTime(6000, now);
          filter.Q.setValueAtTime(2, now);
          
          filter2.type = 'bandpass';
          filter2.frequency.setValueAtTime(8000, now);
          filter2.frequency.exponentialRampToValueAtTime(4000, now + 0.04);
          filter2.Q.setValueAtTime(5, now);
          
          osc.frequency.setValueAtTime(3000, now);
          osc.frequency.exponentialRampToValueAtTime(1500, now + 0.03);
          osc.type = 'sine';
          
          gain.gain.setValueAtTime(0.08, now);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);
          noiseGain.gain.setValueAtTime(0.12, now);
          noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
          
          osc.start(now);
          osc.stop(now + 0.04);
          noise.start(now);
          noise.stop(now + 0.05);
          break;
        }
      }
    }
    
    // ãƒ›ãƒ¯ã‚¤ãƒˆãƒã‚¤ã‚ºç”Ÿæˆ
    function createNoise() {
      const bufferSize = audioCtx.sampleRate * 0.5;
      const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
      }
      const noise = audioCtx.createBufferSource();
      noise.buffer = buffer;
      return noise;
    }
    
    // Player
    const TOUCH_OFFSET_Y = 100; // è‡ªæ©Ÿã‚’ã‚¿ãƒƒãƒä½ç½®ã‚ˆã‚Šä¸Šã«é…ç½®
    const player = {
      x: GAME_WIDTH / 2,
      y: GAME_HEIGHT - 150,
      width: 20,
      height: 24,
      hitboxRadius: 4, // å½“ãŸã‚Šåˆ¤å®šã®åŠå¾„
      speed: 8,
      targetX: GAME_WIDTH / 2,
      targetY: GAME_HEIGHT - 150,
      invincible: 0,
      fireRate: 10, // åˆæœŸé€£å°„é€Ÿåº¦
      lastFire: 0,
      power: 0, // ãƒ‘ãƒ¯ãƒ¼ãƒ¬ãƒ™ãƒ«ï¼ˆ0-9ï¼‰
      shotCount: 1, // ã‚·ãƒ§ãƒƒãƒˆæœ¬æ•°
      bombs: 3, // ãƒœãƒ ã®æ•°
      maxBombs: 3,
      homingFireRate: 30, // ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å¼¾ã®ç™ºå°„é–“éš”
      lastHomingFire: 0,
      shipType: 'shot', // æ©Ÿä½“ã‚¿ã‚¤ãƒ—: shot, laser, bomb
      weaponMode: 'shot', // æ­¦å™¨ãƒ¢ãƒ¼ãƒ‰: shot, laser
      laserActive: false,
      laserDamageTimer: 0
    };
    
    // æ©Ÿä½“ã‚¿ã‚¤ãƒ—åˆ¥ã®è¨­å®š
    const SHIP_TYPES = {
      shot: {
        shotMult: 1.5,    // ã‚·ãƒ§ãƒƒãƒˆå¼·åŒ–å€ç‡
        laserMult: 0.7,   // ãƒ¬ãƒ¼ã‚¶ãƒ¼å¼±ä½“
        bombs: 3,
        bombRecovery: false
      },
      laser: {
        shotMult: 0.7,    // ã‚·ãƒ§ãƒƒãƒˆå¼±ä½“
        laserMult: 1.5,   // ãƒ¬ãƒ¼ã‚¶ãƒ¼å¼·åŒ–å€ç‡
        bombs: 3,
        bombRecovery: false
      },
      bomb: {
        shotMult: 1.0,
        laserMult: 1.0,
        bombs: 5,         // ãƒœãƒ å¢—é‡
        bombRecovery: true // è¢«å¼¾æ™‚ãƒœãƒ å›å¾©
      }
    };
    
    // ãƒœãƒ ã‚¨ãƒ•ã‚§ã‚¯ãƒˆçŠ¶æ…‹
    let bombEffect = {
      active: false,
      frame: 0,
      duration: 45
    };
    
    // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—è¨­å®š
    const POWER_LEVELS = [
      { fireRate: 10, shotCount: 1 }, // Level 0
      { fireRate: 9,  shotCount: 1 }, // Level 1
      { fireRate: 8,  shotCount: 2 }, // Level 2
      { fireRate: 7,  shotCount: 2 }, // Level 3
      { fireRate: 6,  shotCount: 3 }, // Level 4
      { fireRate: 5,  shotCount: 3 }, // Level 5
      { fireRate: 5,  shotCount: 4 }, // Level 6
      { fireRate: 4,  shotCount: 4 }, // Level 7
      { fireRate: 4,  shotCount: 5 }, // Level 8
      { fireRate: 3,  shotCount: 5 }, // Level 9 (MAX)
    ];
    
    // Object pools
    let playerBullets = [];
    let homingBullets = []; // ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å¼¾
    let playerLaser = null; // è‡ªæ©Ÿãƒ¬ãƒ¼ã‚¶ãƒ¼
    let enemies = [];
    let enemyBullets = [];
    let lasers = []; // æ•µãƒ¬ãƒ¼ã‚¶ãƒ¼æ”»æ’ƒ
    let particles = [];
    let items = []; // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—ã‚¢ã‚¤ãƒ†ãƒ 
    
    // Dot patterns for sprites
    const SPRITES = {
      player: [
        '....1....',
        '...111...',
        '..11111..',
        '.1111111.',
        '111111111',
        '111111111',
        '.1.111.1.',
        '1..111..1'
      ],
      enemy1: [
        '.111111.',
        '11111111',
        '1.1111.1',
        '11111111',
        '.111111.',
        '..1..1..'
      ],
      enemy2: [
        '..1111..',
        '.111111.',
        '111..111',
        '11111111',
        '.11..11.',
        '.1....1.'
      ],
      boss: [
        '...1111111...',
        '..111111111..',
        '.11111111111.',
        '1111111111111',
        '111.11111.111',
        '1111111111111',
        '1111111111111',
        '.111.111.111.',
        '..11.....11..',
        '..1.......1..'
      ],
      miniboss: [
        '..111111..',
        '.1111111..',
        '1111111111',
        '111.11.111',
        '1111111111',
        '1111111111',
        '.11.11.11.',
        '.1......1.'
      ]
    };
    
    // Draw sprite from dot pattern
    function drawSprite(pattern, x, y, dotSize = 3, alpha = 1) {
      ctx.fillStyle = `rgba(${getFgColorRgb()}, ${alpha})`;
      const width = pattern[0].length * dotSize;
      const height = pattern.length * dotSize;
      const startX = x - width / 2;
      const startY = y - height / 2;
      
      for (let row = 0; row < pattern.length; row++) {
        for (let col = 0; col < pattern[row].length; col++) {
          if (pattern[row][col] === '1') {
            ctx.fillRect(
              startX + col * dotSize,
              startY + row * dotSize,
              dotSize - 1,
              dotSize - 1
            );
          }
        }
      }
      return { width, height };
    }
    
    // Player class
    function updatePlayer() {
      // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å¾…æ©Ÿä¸­ã¯ä½•ã‚‚ã—ãªã„
      if (gameOverPending) return;
      
      // å³åº§ã«ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã«ç§»å‹•
      player.x = player.targetX;
      player.y = player.targetY;
      
      // Keep player in bounds (ä¸‹éƒ¨ã«ä½™ç™½ã‚’è¨­ã‘ã‚‹)
      player.x = Math.max(15, Math.min(GAME_WIDTH - 15, player.x));
      player.y = Math.max(50, Math.min(GAME_HEIGHT - 150, player.y));
      
      // ãƒ‘ãƒ¯ãƒ¼ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸé€£å°„
      const powerStats = POWER_LEVELS[player.power];
      const shipConfig = SHIP_TYPES[player.shipType];
      
      // æ­¦å™¨ãƒ¢ãƒ¼ãƒ‰ã«å¿œã˜ã¦æ”»æ’ƒ
      if (player.weaponMode === 'shot') {
        // ã‚·ãƒ§ãƒƒãƒˆãƒ¢ãƒ¼ãƒ‰
        if (frameCount - player.lastFire >= powerStats.fireRate) {
          firePlayerBullets(powerStats.shotCount);
          player.lastFire = frameCount;
        }
        player.laserActive = false;
        playerLaser = null;
      } else {
        // ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒ¢ãƒ¼ãƒ‰
        player.laserActive = true;
        updatePlayerLaser();
      }
      
      // ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å¼¾ç™ºå°„ï¼ˆãƒ‘ãƒ¯ãƒ¼ãƒ¬ãƒ™ãƒ«2ä»¥ä¸Šã§ç™ºå°„ã€ä¸¡ãƒ¢ãƒ¼ãƒ‰å…±é€šï¼‰
      if (player.power >= 2 && frameCount - player.lastHomingFire >= player.homingFireRate) {
        fireHomingBullets();
        player.lastHomingFire = frameCount;
      }
      
      // Update invincibility
      if (player.invincible > 0) player.invincible--;
    }
    
    // è‡ªæ©Ÿãƒ¬ãƒ¼ã‚¶ãƒ¼æ›´æ–°
    function updatePlayerLaser() {
      const shipConfig = SHIP_TYPES[player.shipType];
      // ãƒ¬ãƒ¼ã‚¶ãƒ¼ã®å¤ªã•ï¼ˆãƒ‘ãƒ¯ãƒ¼ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦å¤ªããªã‚‹ï¼‰
      const baseWidth = 6 + player.power * 1.5;
      const width = baseWidth * shipConfig.laserMult;
      
      playerLaser = {
        x: player.x,
        y: player.y - 15,
        width: Math.max(4, width),
        // ãƒ€ãƒ¡ãƒ¼ã‚¸ï¼ˆãƒ‘ãƒ¯ãƒ¼ãƒ¬ãƒ™ãƒ«ã¨æ©Ÿä½“ã‚¿ã‚¤ãƒ—ã«å¿œã˜ã¦ï¼‰
        damage: (0.5 + player.power * 0.15) * shipConfig.laserMult
      };
      
      // ãƒ¬ãƒ¼ã‚¶ãƒ¼ãƒ€ãƒ¡ãƒ¼ã‚¸å‡¦ç†ï¼ˆãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ï¼‰
      player.laserDamageTimer++;
      if (player.laserDamageTimer >= 3) { // 3ãƒ•ãƒ¬ãƒ¼ãƒ ã”ã¨ã«ãƒ€ãƒ¡ãƒ¼ã‚¸
        applyLaserDamage();
        player.laserDamageTimer = 0;
        // ãƒ¬ãƒ¼ã‚¶ãƒ¼éŸ³ï¼ˆé–“å¼•ã„ã¦å†ç”Ÿï¼‰
        if (frameCount % 6 === 0) {
          playSound('laser');
        }
      }
    }
    
    // ãƒ¬ãƒ¼ã‚¶ãƒ¼ã®ãƒ€ãƒ¡ãƒ¼ã‚¸é©ç”¨
    function applyLaserDamage() {
      if (!playerLaser) return;
      
      for (let j = enemies.length - 1; j >= 0; j--) {
        const e = enemies[j];
        // ãƒ¬ãƒ¼ã‚¶ãƒ¼ã¨ã®å½“ãŸã‚Šåˆ¤å®šï¼ˆç¸¦æ–¹å‘ã®ãƒ©ã‚¤ãƒ³ï¼‰
        if (Math.abs(e.x - playerLaser.x) < (e.width/2 + playerLaser.width/2) && e.y > 0) {
          // ç™»å ´ä¸­ã¾ãŸã¯ãƒãƒªã‚¢ä¸­ã¯ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆãªã„
          if ((e.isMiniboss || e.isBoss) && (e.entryPhase || e.barrier)) {
            continue;
          }
          
          e.hp -= playerLaser.damage;
          
          // ãƒ’ãƒƒãƒˆã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
          if (frameCount % 6 === 0) {
            spawnParticles(e.x, e.y, 2);
          }
          
          if (e.hp <= 0) {
            const particleCount = e.isBoss ? 50 : (e.isMiniboss ? 25 : 10);
            spawnParticles(e.x, e.y, particleCount);
            
            // ã‚¢ã‚¤ãƒ†ãƒ ãƒ‰ãƒ­ãƒƒãƒ—
            handleEnemyDrop(e);
            
            // ã‚¹ã‚³ã‚¢
            score += e.isBoss ? 5000 : (e.isMiniboss ? 1000 : 100);
            
            // åŠ¹æœéŸ³
            playSound((e.isBoss || e.isMiniboss) ? 'bossDestroy' : 'enemyDestroy');
            
            // æ‰“ã¡è¿”ã—å¼¾
            if (!e.isMiniboss && !e.isBoss && player.power >= 4) {
              const bulletCount = 4 + Math.floor((player.power - 4) / 2) * 2;
              spawnRevengeBullets(e.x, e.y, bulletCount);
            }
            
            // ãƒ•ã‚§ãƒ¼ã‚ºé€²è¡Œ
            handleEnemyDefeated(e);
            
            enemies.splice(j, 1);
          }
        }
      }
    }
    
    // è‡ªæ©Ÿãƒ¬ãƒ¼ã‚¶ãƒ¼æç”»
    function drawPlayerLaser() {
      if (!playerLaser || !player.laserActive || gameOverPending) return;
      
      const fgRgb = getFgColorRgb();
      const pulseAlpha = 0.8 + Math.sin(frameCount * 0.4) * 0.2;
      
      // å¤–å´ã®ã‚°ãƒ­ãƒ¼ï¼ˆåºƒã„å…‰å½©ï¼‰
      const glowGradient = ctx.createLinearGradient(
        playerLaser.x - playerLaser.width * 4, 0,
        playerLaser.x + playerLaser.width * 4, 0
      );
      glowGradient.addColorStop(0, `rgba(${fgRgb}, 0)`);
      glowGradient.addColorStop(0.3, `rgba(${fgRgb}, 0.15)`);
      glowGradient.addColorStop(0.5, `rgba(${fgRgb}, 0.3)`);
      glowGradient.addColorStop(0.7, `rgba(${fgRgb}, 0.15)`);
      glowGradient.addColorStop(1, `rgba(${fgRgb}, 0)`);
      
      ctx.fillStyle = glowGradient;
      ctx.fillRect(
        playerLaser.x - playerLaser.width * 4,
        0,
        playerLaser.width * 8,
        playerLaser.y
      );
      
      // ä¸­é–“å±¤ï¼ˆæ¿ƒã„ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
      const midGradient = ctx.createLinearGradient(
        playerLaser.x - playerLaser.width * 1.5, 0,
        playerLaser.x + playerLaser.width * 1.5, 0
      );
      midGradient.addColorStop(0, `rgba(${fgRgb}, 0)`);
      midGradient.addColorStop(0.2, `rgba(${fgRgb}, 0.5)`);
      midGradient.addColorStop(0.5, `rgba(${fgRgb}, 0.8)`);
      midGradient.addColorStop(0.8, `rgba(${fgRgb}, 0.5)`);
      midGradient.addColorStop(1, `rgba(${fgRgb}, 0)`);
      
      ctx.fillStyle = midGradient;
      ctx.fillRect(
        playerLaser.x - playerLaser.width * 1.5,
        0,
        playerLaser.width * 3,
        playerLaser.y
      );
      
      // ã‚³ã‚¢ï¼ˆä¸­å¿ƒã®æ¿ƒã„ç·šï¼‰
      ctx.fillStyle = `rgba(${fgRgb}, ${pulseAlpha})`;
      ctx.fillRect(
        playerLaser.x - playerLaser.width / 2,
        0,
        playerLaser.width,
        playerLaser.y
      );
      
      // æœ€ã‚‚æ˜ã‚‹ã„ä¸­å¿ƒç·š
      ctx.fillStyle = getFgColor();
      ctx.fillRect(
        playerLaser.x - 1,
        0,
        2,
        playerLaser.y
      );
      
      // ã‚¨ãƒƒã‚¸ãƒ©ã‚¤ãƒ³ï¼ˆè¼ªéƒ­å¼·èª¿ï¼‰
      ctx.strokeStyle = `rgba(${fgRgb}, ${pulseAlpha * 0.7})`;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(playerLaser.x - playerLaser.width / 2, 0);
      ctx.lineTo(playerLaser.x - playerLaser.width / 2, playerLaser.y);
      ctx.moveTo(playerLaser.x + playerLaser.width / 2, 0);
      ctx.lineTo(playerLaser.x + playerLaser.width / 2, playerLaser.y);
      ctx.stroke();
      
      // ç™ºå°„å£ã®ãƒ•ãƒ©ãƒƒã‚·ãƒ¥
      const flashSize = 8 + Math.sin(frameCount * 0.5) * 3;
      const flashGradient = ctx.createRadialGradient(
        playerLaser.x, playerLaser.y, 0,
        playerLaser.x, playerLaser.y, flashSize
      );
      flashGradient.addColorStop(0, `rgba(${fgRgb}, 1)`);
      flashGradient.addColorStop(0.5, `rgba(${fgRgb}, 0.5)`);
      flashGradient.addColorStop(1, `rgba(${fgRgb}, 0)`);
      
      ctx.fillStyle = flashGradient;
      ctx.beginPath();
      ctx.arc(playerLaser.x, playerLaser.y, flashSize, 0, Math.PI * 2);
      ctx.fill();
    }
    
    function firePlayerBullets(count) {
      const shipConfig = SHIP_TYPES[player.shipType];
      // ã‚·ãƒ§ãƒƒãƒˆã‚¿ã‚¤ãƒ—ã¯å¼¾æ•°å¢—åŠ 
      const adjustedCount = player.shipType === 'shot' ? Math.ceil(count * 1.2) : count;
      
      // ã‚·ãƒ§ãƒƒãƒˆéŸ³ï¼ˆé€£å°„ã‚’è€ƒæ…®ã—ã¦é–“å¼•ãï¼‰
      if (frameCount % 2 === 0) {
        playSound('shot');
      }
      
      if (adjustedCount === 1) {
        // 1ç™ºï¼šã¾ã£ã™ã
        playerBullets.push({
          x: player.x,
          y: player.y - 15,
          vx: 0,
          vy: -14,
          width: 4,
          height: 8
        });
      } else if (adjustedCount === 2) {
        // 2ç™ºï¼šã¾ã£ã™ã2æœ¬ï¼ˆå°‘ã—å·¦å³ã«ãšã‚‰ã™ï¼‰
        playerBullets.push({
          x: player.x - 5,
          y: player.y - 15,
          vx: 0,
          vy: -14,
          width: 4,
          height: 8
        });
        playerBullets.push({
          x: player.x + 5,
          y: player.y - 15,
          vx: 0,
          vy: -14,
          width: 4,
          height: 8
        });
      } else {
        // 3ç™ºä»¥ä¸Šï¼šä¸­å¤®ã¯ã¾ã£ã™ãã€å·¦å³ã«åºƒãŒã‚‹å¼¾ã‚’è¿½åŠ 
        const speed = 14;
        
        // ä¸­å¤®ã®ã¾ã£ã™ããªå¼¾ï¼ˆå¸¸ã«1ç™ºï¼‰
        playerBullets.push({
          x: player.x,
          y: player.y - 15,
          vx: 0,
          vy: -speed,
          width: 4,
          height: 8
        });
        
        // å·¦å³ã«åºƒãŒã‚‹å¼¾
        const sideCount = adjustedCount - 1; // ä¸­å¤®ä»¥å¤–ã®å¼¾æ•°
        const maxAngle = Math.PI * 0.25; // æœ€å¤§åºƒãŒã‚Šè§’åº¦ï¼ˆç´„45åº¦ï¼‰
        
        for (let i = 0; i < sideCount; i++) {
          // å·¦å³äº¤äº’ã«é…ç½®ã€å¾ã€…ã«è§’åº¦ã‚’åºƒã’ã‚‹
          const side = (i % 2 === 0) ? 1 : -1; // å³ã€å·¦ã€å³ã€å·¦...
          const level = Math.floor(i / 2) + 1; // 1, 1, 2, 2, 3, 3...
          const angle = (maxAngle / Math.ceil(sideCount / 2)) * level * side;
          
          playerBullets.push({
            x: player.x,
            y: player.y - 15,
            vx: Math.sin(angle) * speed,
            vy: -Math.cos(angle) * speed,
            width: 4,
            height: 8
          });
        }
      }
    }
    
    // ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å¼¾ç™ºå°„
    function fireHomingBullets() {
      if (enemies.length === 0) return;
      
      playSound('homing');
      
      // ãƒ‘ãƒ¯ãƒ¼ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å¼¾ã®æ•°ã‚’å¢—ã‚„ã™ï¼ˆ1ã€œ3ç™ºï¼‰
      const homingCount = Math.min(3, Math.floor((player.power - 1) / 3) + 1);
      
      for (let i = 0; i < homingCount; i++) {
        const offsetX = (i - (homingCount - 1) / 2) * 15;
        homingBullets.push({
          x: player.x + offsetX,
          y: player.y - 10,
          vx: offsetX * 0.3,
          vy: -5,
          speed: 8,
          turnRate: 0.15, // æ—‹å›é€Ÿåº¦
          radius: 5,
          life: 180 // 3ç§’ã§æ¶ˆãˆã‚‹
        });
      }
    }
    
    // ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å¼¾æ›´æ–°
    function updateHomingBullets() {
      for (let i = homingBullets.length - 1; i >= 0; i--) {
        const h = homingBullets[i];
        
        // æœ€ã‚‚è¿‘ã„æ•µã‚’æ¢ã™
        let nearestEnemy = null;
        let nearestDist = Infinity;
        for (const e of enemies) {
          const dx = e.x - h.x;
          const dy = e.y - h.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          if (dist < nearestDist) {
            nearestDist = dist;
            nearestEnemy = e;
          }
        }
        
        // æ•µã«å‘ã‹ã£ã¦æ—‹å›
        if (nearestEnemy) {
          const targetAngle = Math.atan2(nearestEnemy.y - h.y, nearestEnemy.x - h.x);
          const currentAngle = Math.atan2(h.vy, h.vx);
          
          // è§’åº¦å·®ã‚’è¨ˆç®—ï¼ˆ-PIã€œPIã«æ­£è¦åŒ–ï¼‰
          let angleDiff = targetAngle - currentAngle;
          while (angleDiff > Math.PI) angleDiff -= Math.PI * 2;
          while (angleDiff < -Math.PI) angleDiff += Math.PI * 2;
          
          // æ—‹å›
          const newAngle = currentAngle + Math.sign(angleDiff) * Math.min(Math.abs(angleDiff), h.turnRate);
          h.vx = Math.cos(newAngle) * h.speed;
          h.vy = Math.sin(newAngle) * h.speed;
        }
        
        // ç§»å‹•
        h.x += h.vx;
        h.y += h.vy;
        h.life--;
        
        // ç”»é¢å¤–ã¾ãŸã¯å¯¿å‘½åˆ‡ã‚Œã§å‰Šé™¤
        if (h.x < -20 || h.x > GAME_WIDTH + 20 || h.y < -20 || h.y > GAME_HEIGHT + 20 || h.life <= 0) {
          homingBullets.splice(i, 1);
        }
      }
    }
    
    // ãƒ›ãƒ¼ãƒŸãƒ³ã‚°å¼¾æç”»
    function drawHomingBullets() {
      for (const h of homingBullets) {
        // ä¸‰è§’å½¢ã§æç”»ï¼ˆé€²è¡Œæ–¹å‘ã‚’å‘ãï¼‰
        const angle = Math.atan2(h.vy, h.vx);
        ctx.save();
        ctx.translate(h.x, h.y);
        ctx.rotate(angle);
        
        ctx.fillStyle = '#666';
        ctx.beginPath();
        ctx.moveTo(8, 0);
        ctx.lineTo(-5, -4);
        ctx.lineTo(-5, 4);
        ctx.closePath();
        ctx.fill();
        
        ctx.restore();
      }
    }
    
    function drawPlayer() {
      // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å¾…æ©Ÿä¸­ã¯è‡ªæ©Ÿã‚’è¡¨ç¤ºã—ãªã„
      if (gameOverPending) return;
      if (player.invincible > 0 && frameCount % 6 < 3) return;
      drawSprite(SPRITES.player, player.x, player.y, 3);
      
      // å½“ãŸã‚Šåˆ¤å®šã‚’èµ¤ã„ãƒ‰ãƒƒãƒˆã§è¡¨ç¤º
      ctx.fillStyle = '#ff0000';
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.hitboxRadius, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Enemy spawning - æ–°ã‚µã‚¤ã‚¯ãƒ«ã‚·ã‚¹ãƒ†ãƒ 
    // ã‚µã‚¤ã‚¯ãƒ«: é€šå¸¸æ•µâ†’ä¸­ãƒœã‚¹â†’é€šå¸¸æ•µâ†’å¤§ãƒœã‚¹
    let gamePhase = 'normal1'; // normal1, miniboss, normal2, boss
    let phaseTimer = 0;
    let bossDefeatedCount = 0; // å€’ã—ãŸå¤§ãƒœã‚¹ã®æ•°
    let bombItemDropped = false; // ã“ã®ã‚µã‚¤ã‚¯ãƒ«ã§ãƒœãƒ ã‚¢ã‚¤ãƒ†ãƒ ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã—ãŸã‹
    
    const NORMAL_PHASE_DURATION = 600; // é€šå¸¸ãƒ•ã‚§ãƒ¼ã‚º10ç§’
    const BOSS_DEFEATED_COOLDOWN = 300; // å¤§ãƒœã‚¹æ’ƒç ´å¾Œ5ç§’
    let bossDefeatedCooldown = 0;
    
    function spawnEnemy() {
      // é€šå¸¸ã®å°å‹æ•µï¼ˆ1ç™ºã§å€’ã›ã‚‹ï¼‰
      const type = Math.random() < 0.5 ? 'enemy1' : 'enemy2';
      
      enemies.push({
        x: Math.random() * (GAME_WIDTH - 60) + 30,
        y: -30,
        type: type,
        hp: 1, // å°å‹æ•µã¯1ç™ºã§å€’ã›ã‚‹
        maxHp: 1,
        speed: 1.5 + Math.random() * difficulty,
        fireRate: 60 + Math.random() * 60,
        lastFire: 0,
        pattern: Math.random() < 0.5 ? 'aimed' : 'spread',
        width: 24,
        height: 18,
        movePhase: Math.random() * Math.PI * 2,
        isMiniboss: false,
        isBoss: false
      });
    }
    
    function spawnMiniboss() {
      const patterns = ['radial', 'spiral', 'burst'];
      
      // è‡ªæ©Ÿã®ãƒ‘ãƒ¯ãƒ¼ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸDPSè¨ˆç®—
      const powerStats = POWER_LEVELS[player.power];
      const shotsPerSecond = 60 / powerStats.fireRate;
      const dps = shotsPerSecond * powerStats.shotCount;
      
      // ç´„3ç§’ã§å€’ã›ã‚‹HP
      const calculatedHp = Math.ceil(dps * 10 / 6);
      
      // ãƒ¬ãƒ¼ã‚¶ãƒ¼æœ¬æ•°ï¼ˆãƒ‘ãƒ¯ãƒ¼ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ã¦1ã€œ3æœ¬ï¼‰
      const laserCount = player.power < 3 ? 1 : (player.power < 6 ? 2 : 3);
      
      // å¼¾å¹•ã®å¼·ã•
      const bulletFireRate = Math.max(22, 30 - player.power * 0.9);
      const bulletSpeedMult = 1 + player.power * 0.028;
      const bulletCountMult = 1 + player.power * 0.022;
      
      enemies.push({
        x: GAME_WIDTH / 2,
        y: -40,
        type: 'miniboss',
        hp: calculatedHp,
        maxHp: calculatedHp,
        speed: 0.8,
        fireRate: bulletFireRate,
        lastFire: 0,
        pattern: patterns[Math.floor(Math.random() * patterns.length)],
        width: 50,
        height: 40,
        movePhase: Math.random() * Math.PI * 2,
        isMiniboss: true,
        isBoss: false,
        targetY: 120,
        laserCooldown: -180,
        laserInterval: 180,
        laserCount: laserCount,
        bulletSpeedMult: bulletSpeedMult,
        bulletCountMult: bulletCountMult,
        // ç™»å ´æ¼”å‡º
        entryPhase: true,
        entryTimer: 0,
        // ãƒãƒªã‚¢
        barrier: false,
        barrierTimer: 0
      });
    }
    
    function spawnBoss() {
      // è‡ªæ©Ÿã®ãƒ‘ãƒ¯ãƒ¼ãƒ¬ãƒ™ãƒ«ã«å¿œã˜ãŸDPSè¨ˆç®—
      const powerStats = POWER_LEVELS[player.power];
      const shotsPerSecond = 60 / powerStats.fireRate;
      const dps = shotsPerSecond * powerStats.shotCount;
      
      // ç´„15ç§’ã§å€’ã›ã‚‹HPï¼ˆå¤§ãƒœã‚¹ã¯å¼·ã„ï¼‰
      const calculatedHp = Math.ceil(dps * 15);
      
      // å¤§ãƒœã‚¹ã¯ç”»é¢å¹…ã®80%
      const bossWidth = GAME_WIDTH * 0.8;
      
      enemies.push({
        x: GAME_WIDTH / 2,
        y: -80,
        type: 'boss',
        hp: calculatedHp,
        maxHp: calculatedHp,
        speed: 0.5,
        fireRate: 15, // é«˜é€Ÿé€£å°„
        lastFire: 0,
        pattern: 'boss',
        width: bossWidth,
        height: 60,
        movePhase: Math.random() * Math.PI * 2,
        isMiniboss: false,
        isBoss: true,
        targetY: 100,
        // å¤§ãƒœã‚¹å°‚ç”¨ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
        laserCooldown: -120,
        laserInterval: 240, // 4ç§’ã”ã¨ã«ãƒ¬ãƒ¼ã‚¶ãƒ¼
        laserCount: 5, // 5æœ¬ã®ãƒ¬ãƒ¼ã‚¶ãƒ¼
        attackPhase: 0,
        attackTimer: 0,
        bulletSpeedMult: 1.2 + bossDefeatedCount * 0.1,
        bulletCountMult: 1.3 + bossDefeatedCount * 0.1,
        // ç™»å ´æ¼”å‡º
        entryPhase: true,
        entryTimer: 0,
        // ãƒãƒªã‚¢
        barrier: false,
        barrierTimer: 0
      });
    }
    
    // å¤§ãƒœã‚¹ã®æç”»
    function drawBoss(e) {
      ctx.save();
      ctx.translate(e.x, e.y);
      
      // ãƒ¡ã‚¤ãƒ³ãƒœãƒ‡ã‚£ï¼ˆå…­è§’å½¢é¢¨ï¼‰
      ctx.fillStyle = darkMode ? '#eee' : '#111';
      ctx.beginPath();
      const w = e.width / 2;
      const h = e.height / 2;
      ctx.moveTo(-w, 0);
      ctx.lineTo(-w * 0.7, -h);
      ctx.lineTo(w * 0.7, -h);
      ctx.lineTo(w, 0);
      ctx.lineTo(w * 0.7, h);
      ctx.lineTo(-w * 0.7, h);
      ctx.closePath();
      ctx.fill();
      
      // å†…éƒ¨ãƒ‘ã‚¿ãƒ¼ãƒ³
      ctx.strokeStyle = darkMode ? '#aaa' : '#333';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-w * 0.5, -h * 0.5);
      ctx.lineTo(w * 0.5, -h * 0.5);
      ctx.lineTo(w * 0.5, h * 0.5);
      ctx.lineTo(-w * 0.5, h * 0.5);
      ctx.closePath();
      ctx.stroke();
      
      // ã‚³ã‚¢ï¼ˆç‚¹æ»…ï¼‰
      const pulse = Math.sin(frameCount * 0.1) * 0.3 + 0.7;
      ctx.fillStyle = darkMode ? `rgba(200, 200, 200, ${pulse})` : `rgba(50, 50, 50, ${pulse})`;
      ctx.beginPath();
      ctx.arc(0, 0, 20, 0, Math.PI * 2);
      ctx.fill();
      
      // ç ²å°
      ctx.fillStyle = darkMode ? '#ccc' : '#222';
      for (let i = -2; i <= 2; i++) {
        ctx.fillRect(i * w * 0.35 - 8, h - 5, 16, 15);
      }
      
      ctx.restore();
    }
    
    // å¤§ãƒœã‚¹ã®æ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³
    function fireBossBullets(e) {
      e.attackTimer++;
      
      // æ”»æ’ƒãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ‡ã‚Šæ›¿ãˆ
      if (e.attackTimer >= 180) { // 3ç§’ã”ã¨ã«ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ‡ã‚Šæ›¿ãˆ
        e.attackPhase = (e.attackPhase + 1) % 4;
        e.attackTimer = 0;
      }
      
      const baseSpeed = 3 * e.bulletSpeedMult;
      
      switch(e.attackPhase) {
        case 0: // è‡ªæ©Ÿç‹™ã„å¼¾å¹•
          if (frameCount % Math.floor(20 / e.bulletCountMult) === 0) {
            const angle = Math.atan2(player.y - e.y, player.x - e.x);
            for (let i = -2; i <= 2; i++) {
              const spreadAngle = angle + i * 0.15;
              enemyBullets.push({
                x: e.x,
                y: e.y + e.height / 2,
                vx: Math.cos(spreadAngle) * baseSpeed,
                vy: Math.sin(spreadAngle) * baseSpeed,
                radius: 4
              });
            }
          }
          break;
          
        case 1: // å…¨æ–¹ä½å¼¾
          if (frameCount % Math.floor(30 / e.bulletCountMult) === 0) {
            const count = Math.floor(16 * e.bulletCountMult);
            for (let i = 0; i < count; i++) {
              const angle = (Math.PI * 2 / count) * i + frameCount * 0.02;
              enemyBullets.push({
                x: e.x,
                y: e.y + e.height / 2,
                vx: Math.cos(angle) * baseSpeed * 0.8,
                vy: Math.sin(angle) * baseSpeed * 0.8,
                radius: 3
              });
            }
          }
          break;
          
        case 2: // 5ç ²å°ã‹ã‚‰é€£å°„
          if (frameCount % Math.floor(8 / e.bulletCountMult) === 0) {
            for (let i = -2; i <= 2; i++) {
              const gunX = e.x + i * e.width * 0.175;
              // è‡ªæ©Ÿç‹™ã„ã¨å›ºå®šè§’åº¦ã®ãƒŸãƒƒã‚¯ã‚¹
              const aimed = Math.random() < 0.5;
              let angle;
              if (aimed) {
                angle = Math.atan2(player.y - e.y, player.x - gunX);
              } else {
                angle = Math.PI / 2 + (Math.random() - 0.5) * 0.5;
              }
              enemyBullets.push({
                x: gunX,
                y: e.y + e.height / 2 + 10,
                vx: Math.cos(angle) * baseSpeed,
                vy: Math.sin(angle) * baseSpeed,
                radius: 4
              });
            }
          }
          break;
          
        case 3: // æ‰‡çŠ¶å¼¾å¹•
          if (frameCount % Math.floor(12 / e.bulletCountMult) === 0) {
            const count = Math.floor(12 * e.bulletCountMult);
            const spread = Math.PI * 0.6;
            for (let i = 0; i < count; i++) {
              const angle = Math.PI / 2 - spread / 2 + (spread / (count - 1)) * i;
              enemyBullets.push({
                x: e.x,
                y: e.y + e.height / 2,
                vx: Math.cos(angle) * baseSpeed,
                vy: Math.sin(angle) * baseSpeed,
                radius: 3
              });
            }
          }
          break;
      }
    }
    
    // å¤§ãƒœã‚¹ã®ãƒ¬ãƒ¼ã‚¶ãƒ¼æ”»æ’ƒ
    function fireBossLaser(e) {
      const positions = [];
      const w = e.width * 0.4;
      
      // 5æœ¬ã®ãƒ¬ãƒ¼ã‚¶ãƒ¼ä½ç½®
      positions.push(e.x - w);
      positions.push(e.x - w / 2);
      positions.push(e.x);
      positions.push(e.x + w / 2);
      positions.push(e.x + w);
      
      for (const targetX of positions) {
        lasers.push({
          x: e.x,
          startY: e.y + e.height / 2,
          targetX: targetX + (Math.random() - 0.5) * 60, // å°‘ã—ãƒ©ãƒ³ãƒ€ãƒ ã«ãšã‚‰ã™
          width: 8,
          phase: 'warning',
          warningDuration: 60,
          firingDuration: 45,
          frame: 0
        });
      }
    }
    
    function updateEnemies() {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        
        // ãƒãƒªã‚¢ã‚¿ã‚¤ãƒãƒ¼æ›´æ–°
        if (e.barrier && e.barrierTimer > 0) {
          e.barrierTimer--;
          if (e.barrierTimer <= 0) {
            e.barrier = false;
          }
        }
        
        // Movement
        if (e.isBoss) {
          // å¤§ãƒœã‚¹ã¯æŒ‡å®šä½ç½®ã¾ã§é™ã‚Šã¦ãã¦å·¦å³ã«å‹•ã
          if (e.y < e.targetY) {
            e.y += e.speed;
          } else {
            // ç™»å ´å®Œäº†ã€æ”»æ’ƒé–‹å§‹
            if (e.entryPhase) {
              e.entryPhase = false;
              e.entryTimer = 0;
            }
            e.x += Math.sin(frameCount * 0.015 + e.movePhase) * 1.5;
          }
          
          // å¤§ãƒœã‚¹ã®ãƒ¬ãƒ¼ã‚¶ãƒ¼æ”»æ’ƒï¼ˆç™»å ´ä¸­ã¯æ”»æ’ƒã—ãªã„ï¼‰
          if (!e.entryPhase && e.y >= e.targetY) {
            e.laserCooldown++;
            if (e.laserCooldown >= e.laserInterval) {
              fireBossLaser(e);
              e.laserCooldown = 0;
            }
            // å¤§ãƒœã‚¹ã®å¼¾å¹•
            fireBossBullets(e);
          }
        } else if (e.isMiniboss) {
          // ä¸­ãƒœã‚¹ã¯æŒ‡å®šä½ç½®ã¾ã§é™ã‚Šã¦ãã¦å·¦å³ã«å‹•ã
          if (e.y < e.targetY) {
            e.y += e.speed;
          } else {
            // ç™»å ´å®Œäº†ã€æ”»æ’ƒé–‹å§‹
            if (e.entryPhase) {
              e.entryPhase = false;
              e.entryTimer = 0;
            }
          }
          e.x += Math.sin(frameCount * 0.02 + e.movePhase) * 2;
          
          // ãƒ¬ãƒ¼ã‚¶ãƒ¼æ”»æ’ƒï¼ˆç™»å ´ä¸­ã¯æ”»æ’ƒã—ãªã„ï¼‰
          if (!e.entryPhase && e.y >= e.targetY) {
            e.laserCooldown++;
            if (e.laserCooldown >= e.laserInterval) {
              fireLaser(e);
              e.laserCooldown = 0;
            }
          }
        } else {
          // é€šå¸¸æ•µã¯ä¸‹ã«å‘ã‹ã£ã¦ç§»å‹•
          e.y += e.speed;
          e.x += Math.sin(frameCount * 0.05 + e.movePhase) * 1.5;
        }
        
        // Keep in horizontal bounds
        if (e.isBoss) {
          e.x = Math.max(e.width/2 + 10, Math.min(GAME_WIDTH - e.width/2 - 10, e.x));
        } else {
          e.x = Math.max(e.width/2, Math.min(GAME_WIDTH - e.width/2, e.x));
        }
        
        // Remove if off screen (ãƒœã‚¹ã¨ä¸­ãƒœã‚¹ã¯ç”»é¢å¤–ã«å‡ºãªã„)
        if (!e.isMiniboss && !e.isBoss && e.y > GAME_HEIGHT + 50) {
          enemies.splice(i, 1);
          continue;
        }
        
        // Fire bullets (ãƒœã‚¹ã¯å°‚ç”¨å‡¦ç†ã§ç™ºå°„ã€ç™»å ´ä¸­ã¯ç™ºå°„ã—ãªã„)
        if (!e.isBoss && !e.entryPhase && e.y > 50 && frameCount - e.lastFire >= e.fireRate / difficulty) {
          fireEnemyBullet(e);
          e.lastFire = frameCount;
        }
      }
    }
    
    // ãƒ¬ãƒ¼ã‚¶ãƒ¼ç™ºå°„ï¼ˆäºˆå‘Šç·šä»˜ãã€è¤‡æ•°æœ¬å¯¾å¿œï¼‰
    function fireLaser(enemy) {
      const count = enemy.laserCount || 1;
      
      if (count === 1) {
        // 1æœ¬ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç¾åœ¨ä½ç½®ã‚’ç‹™ã†
        lasers.push({
          x: enemy.x,
          startY: enemy.y + 15,
          targetX: player.x,
          width: 6,
          phase: 'warning',
          warningDuration: 60,
          firingDuration: 30,
          frame: 0
        });
      } else if (count === 2) {
        // 2æœ¬ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å·¦å³ã‚’æŒŸã‚€
        const offset = 60;
        lasers.push({
          x: enemy.x,
          startY: enemy.y + 15,
          targetX: player.x - offset,
          width: 6,
          phase: 'warning',
          warningDuration: 60,
          firingDuration: 30,
          frame: 0
        });
        lasers.push({
          x: enemy.x,
          startY: enemy.y + 15,
          targetX: player.x + offset,
          width: 6,
          phase: 'warning',
          warningDuration: 60,
          firingDuration: 30,
          frame: 0
        });
      } else {
        // 3æœ¬ï¼šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ä½ç½®ã¨å·¦å³
        const offset = 80;
        lasers.push({
          x: enemy.x,
          startY: enemy.y + 15,
          targetX: player.x,
          width: 6,
          phase: 'warning',
          warningDuration: 60,
          firingDuration: 30,
          frame: 0
        });
        lasers.push({
          x: enemy.x,
          startY: enemy.y + 15,
          targetX: player.x - offset,
          width: 6,
          phase: 'warning',
          warningDuration: 60,
          firingDuration: 30,
          frame: 0
        });
        lasers.push({
          x: enemy.x,
          startY: enemy.y + 15,
          targetX: player.x + offset,
          width: 6,
          phase: 'warning',
          warningDuration: 60,
          firingDuration: 30,
          frame: 0
        });
      }
    }
    
    function updateLasers() {
      for (let i = lasers.length - 1; i >= 0; i--) {
        const laser = lasers[i];
        laser.frame++;
        
        if (laser.phase === 'warning') {
          // è­¦å‘Šé–‹å§‹æ™‚ã«éŸ³ã‚’é³´ã‚‰ã™
          if (laser.frame === 1) {
            playSound('laserWarning');
          }
          if (laser.frame >= laser.warningDuration) {
            laser.phase = 'firing';
            laser.frame = 0;
            playSound('laserFire');
          }
        } else if (laser.phase === 'firing') {
          // ç™ºå°„ä¸­ã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®å½“ãŸã‚Šåˆ¤å®š
          if (player.invincible === 0) {
            const laserLeft = laser.targetX - laser.width * 3;
            const laserRight = laser.targetX + laser.width * 3;
            if (player.x >= laserLeft && player.x <= laserRight && player.y > laser.startY) {
              // è¢«å¼¾
              lives--;
              player.invincible = 120;
              player.power = Math.max(0, player.power - 2);
              spawnParticles(player.x, player.y, 15);
              if (lives <= 0) {
                gameOver();
              }
            }
          }
          
          if (laser.frame >= laser.firingDuration) {
            lasers.splice(i, 1);
          }
        }
      }
    }
    
    function drawLasers() {
      for (const laser of lasers) {
        if (laser.phase === 'warning') {
          // äºˆå‘Šç·šï¼ˆç‚¹æ»…ã™ã‚‹ç´°ã„ç·šï¼‰
          const alpha = 0.3 + Math.sin(laser.frame * 0.3) * 0.2;
          ctx.strokeStyle = `rgba(255, 0, 0, ${alpha})`;
          ctx.lineWidth = 2;
          ctx.setLineDash([10, 10]);
          ctx.beginPath();
          ctx.moveTo(laser.targetX, laser.startY);
          ctx.lineTo(laser.targetX, GAME_HEIGHT);
          ctx.stroke();
          ctx.setLineDash([]);
          
          // è­¦å‘Šãƒãƒ¼ã‚¯
          const warningY = laser.startY + 50;
          ctx.fillStyle = `rgba(255, 0, 0, ${alpha + 0.3})`;
          ctx.font = 'bold 16px Courier New';
          ctx.textAlign = 'center';
          ctx.fillText('!', laser.targetX, warningY);
          
          // ã‚¿ãƒ¼ã‚²ãƒƒãƒˆä½ç½®ã«ä¸‰è§’å½¢
          ctx.beginPath();
          ctx.moveTo(laser.targetX, GAME_HEIGHT - 20);
          ctx.lineTo(laser.targetX - 10, GAME_HEIGHT);
          ctx.lineTo(laser.targetX + 10, GAME_HEIGHT);
          ctx.closePath();
          ctx.fill();
          
        } else if (laser.phase === 'firing') {
          // ç™ºå°„ä¸­ã®å¤ªã„ãƒ¬ãƒ¼ã‚¶ãƒ¼
          const progress = laser.frame / laser.firingDuration;
          const alpha = 1 - progress * 0.5;
          const width = laser.width * 3 * (1 + Math.sin(laser.frame * 0.5) * 0.2);
          
          // å¤–å´ã®å…‰å½©
          const fgRgb = getFgColorRgb();
          const gradient = ctx.createLinearGradient(laser.targetX - width * 2, 0, laser.targetX + width * 2, 0);
          gradient.addColorStop(0, `rgba(${fgRgb}, 0)`);
          gradient.addColorStop(0.3, `rgba(${fgRgb}, ${alpha * 0.3})`);
          gradient.addColorStop(0.5, `rgba(${fgRgb}, ${alpha})`);
          gradient.addColorStop(0.7, `rgba(${fgRgb}, ${alpha * 0.3})`);
          gradient.addColorStop(1, `rgba(${fgRgb}, 0)`);
          
          ctx.fillStyle = gradient;
          ctx.fillRect(laser.targetX - width * 2, laser.startY, width * 4, GAME_HEIGHT - laser.startY);
          
          // ä¸­å¿ƒã®ç·š
          ctx.fillStyle = `rgba(${fgRgb}, ${alpha})`;
          ctx.fillRect(laser.targetX - width / 2, laser.startY, width, GAME_HEIGHT - laser.startY);
        }
      }
    }
    
    function fireEnemyBullet(enemy) {
      const angle = Math.atan2(player.y - enemy.y, player.x - enemy.x);
      const speedMult = enemy.bulletSpeedMult || 1;
      const countMult = enemy.bulletCountMult || 1;
      
      if (enemy.pattern === 'aimed') {
        enemyBullets.push({
          x: enemy.x,
          y: enemy.y + 10,
          vx: Math.cos(angle) * 4 * speedMult,
          vy: Math.sin(angle) * 4 * speedMult,
          radius: 4
        });
      } else if (enemy.pattern === 'spread') {
        const spreadCount = Math.floor(5 * countMult);
        for (let i = -Math.floor(spreadCount/2); i <= Math.floor(spreadCount/2); i++) {
          const spreadAngle = angle + i * 0.2;
          enemyBullets.push({
            x: enemy.x,
            y: enemy.y + 10,
            vx: Math.cos(spreadAngle) * 3.5 * speedMult,
            vy: Math.sin(spreadAngle) * 3.5 * speedMult,
            radius: 3
          });
        }
      } else if (enemy.pattern === 'radial') {
        // æ”¾å°„çŠ¶å¼¾å¹•
        const bulletCount = Math.floor(16 * countMult);
        for (let i = 0; i < bulletCount; i++) {
          const radialAngle = (Math.PI * 2 / bulletCount) * i + frameCount * 0.03;
          enemyBullets.push({
            x: enemy.x,
            y: enemy.y + 15,
            vx: Math.cos(radialAngle) * 3 * speedMult,
            vy: Math.sin(radialAngle) * 3 * speedMult,
            radius: 4
          });
        }
      } else if (enemy.pattern === 'spiral') {
        // èºæ—‹å¼¾å¹•
        const spiralCount = Math.floor(3 * countMult);
        for (let i = 0; i < spiralCount; i++) {
          const spiralAngle = frameCount * 0.1 + i * (Math.PI * 2 / spiralCount);
          enemyBullets.push({
            x: enemy.x,
            y: enemy.y + 15,
            vx: Math.cos(spiralAngle) * 3.5 * speedMult,
            vy: Math.sin(spiralAngle) * 3.5 * speedMult,
            radius: 4
          });
        }
      } else if (enemy.pattern === 'burst') {
        // ãƒãƒ¼ã‚¹ãƒˆå¼¾å¹•ï¼ˆç‹™ã„æ’ƒã¡ï¼‹æ‹¡æ•£ï¼‰
        const burstCount = Math.floor(7 * countMult);
        for (let i = -Math.floor(burstCount/2); i <= Math.floor(burstCount/2); i++) {
          const burstAngle = angle + i * 0.15;
          enemyBullets.push({
            x: enemy.x,
            y: enemy.y + 15,
            vx: Math.cos(burstAngle) * (3.5 + Math.abs(i) * 0.3) * speedMult,
            vy: Math.sin(burstAngle) * (3.5 + Math.abs(i) * 0.3) * speedMult,
            radius: 3
          });
        }
      }
    }
    
    function drawEnemies() {
      for (const e of enemies) {
        if (e.isBoss) {
          // å¤§ãƒœã‚¹å°‚ç”¨æç”»
          drawBoss(e);
        } else {
          drawSprite(SPRITES[e.type], e.x, e.y, 3);
        }
        
        // ãƒœã‚¹ã¾ãŸã¯ä¸­ãƒœã‚¹ã®ä½“åŠ›ã‚²ãƒ¼ã‚¸ã‚’æç”»
        if (e.isMiniboss || e.isBoss) {
          const barWidth = e.isBoss ? GAME_WIDTH - 40 : 60;
          const barHeight = e.isBoss ? 10 : 6;
          const barX = e.isBoss ? 20 : e.x - barWidth / 2;
          const barY = e.isBoss ? 20 : e.y - 25;
          const hpRatio = e.hp / e.maxHp;
          
          // èƒŒæ™¯ï¼ˆç°è‰²ï¼‰
          ctx.fillStyle = '#ccc';
          ctx.fillRect(barX, barY, barWidth, barHeight);
          
          // HPï¼ˆèµ¤ï¼‰
          ctx.fillStyle = '#ff0000';
          ctx.fillRect(barX, barY, barWidth * hpRatio, barHeight);
          
          // æ 
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 1;
          ctx.strokeRect(barX, barY, barWidth, barHeight);
          
          // ãƒãƒªã‚¢è¡¨ç¤º
          if (e.barrier) {
            const barrierAlpha = 0.3 + Math.sin(frameCount * 0.2) * 0.2;
            ctx.strokeStyle = `rgba(0, 100, 255, ${barrierAlpha})`;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(e.x, e.y, Math.max(e.width, e.height) / 2 + 10, 0, Math.PI * 2);
            ctx.stroke();
            
            // BARRIER ãƒ†ã‚­ã‚¹ãƒˆ
            ctx.fillStyle = `rgba(0, 100, 255, ${barrierAlpha + 0.3})`;
            ctx.font = 'bold 10px Courier New';
            ctx.textAlign = 'center';
            ctx.fillText('BARRIER', e.x, e.y - e.height / 2 - 15);
          }
          
          // ç™»å ´ä¸­è¡¨ç¤º
          if (e.entryPhase) {
            const entryAlpha = 0.5 + Math.sin(frameCount * 0.15) * 0.3;
            ctx.strokeStyle = `rgba(255, 200, 0, ${entryAlpha})`;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(e.x, e.y, Math.max(e.width, e.height) / 2 + 5, 0, Math.PI * 2);
            ctx.stroke();
          }
        }
      }
    }
    
    // Bullets
    function updateBullets() {
      // Player bullets
      for (let i = playerBullets.length - 1; i >= 0; i--) {
        const b = playerBullets[i];
        b.x += b.vx;
        b.y += b.vy;
        if (b.y < -10 || b.x < -10 || b.x > GAME_WIDTH + 10) {
          playerBullets.splice(i, 1);
        }
      }
      
      // Enemy bullets
      for (let i = enemyBullets.length - 1; i >= 0; i--) {
        const b = enemyBullets[i];
        b.x += b.vx;
        b.y += b.vy;
        if (b.x < -20 || b.x > GAME_WIDTH + 20 || b.y < -20 || b.y > GAME_HEIGHT + 20) {
          enemyBullets.splice(i, 1);
        }
      }
    }
    
    function drawBullets() {
      ctx.fillStyle = getFgColor();
      
      // Player bullets (rectangles with rotation)
      for (const b of playerBullets) {
        ctx.save();
        ctx.translate(b.x, b.y);
        const angle = Math.atan2(b.vy, b.vx) + Math.PI / 2;
        ctx.rotate(angle);
        ctx.fillRect(-2, -4, 4, 8);
        ctx.restore();
      }
      
      // Enemy bullets (circles)
      // ãƒ¬ãƒ¼ã‚¶ãƒ¼ã®ç¯„å›²ã‚’è¨ˆç®—
      const laserActive = playerLaser && player.laserActive && !gameOverPending;
      const laserLeft = laserActive ? playerLaser.x - playerLaser.width * 1.5 : 0;
      const laserRight = laserActive ? playerLaser.x + playerLaser.width * 1.5 : 0;
      const laserBottom = laserActive ? playerLaser.y : 0;
      
      for (const b of enemyBullets) {
        // ãƒ¬ãƒ¼ã‚¶ãƒ¼ã¨é‡ãªã£ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        const onLaser = laserActive && 
                        b.x > laserLeft && b.x < laserRight && 
                        b.y < laserBottom;
        
        // ãƒ¬ãƒ¼ã‚¶ãƒ¼ä¸Šãªã‚‰è‰²åè»¢
        if (onLaser) {
          ctx.fillStyle = getBgColor();
          // è¼ªéƒ­ç·šã‚’è¿½åŠ ã—ã¦è¦‹ã‚„ã™ã
          ctx.strokeStyle = getFgColor();
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
          ctx.fill();
          ctx.stroke();
        } else {
          ctx.fillStyle = getFgColor();
          ctx.beginPath();
          ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
    
    // Particles
    function spawnParticles(x, y, count = 8) {
      for (let i = 0; i < count; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 4;
        particles.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 30,
          size: 2 + Math.random() * 3,
          type: 'normal'
        });
      }
    }
    
    // è‡ªæ©Ÿç ´å£Šæ™‚ã®æ´¾æ‰‹ãªã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
    function spawnDeathExplosion(x, y) {
      // å¤§ããªçˆ†ç™ºãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
      for (let i = 0; i < 40; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 6;
        particles.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 60 + Math.random() * 30,
          size: 3 + Math.random() * 6,
          type: 'explosion'
        });
      }
      
      // ãƒªãƒ³ã‚°çŠ¶ã«åºƒãŒã‚‹ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
      for (let i = 0; i < 24; i++) {
        const angle = (Math.PI * 2 / 24) * i;
        const speed = 4;
        particles.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          life: 45,
          size: 4,
          type: 'ring'
        });
      }
      
      // è‡ªæ©Ÿã®æ®‹éª¸ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
      for (let i = 0; i < 15; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 3;
        particles.push({
          x: x + (Math.random() - 0.5) * 20,
          y: y + (Math.random() - 0.5) * 20,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed + 1,
          life: 70 + Math.random() * 20,
          size: 2 + Math.random() * 4,
          type: 'debris',
          rotation: Math.random() * Math.PI * 2,
          rotationSpeed: (Math.random() - 0.5) * 0.3
        });
      }
    }
    
    // ã‚¢ã‚¤ãƒ†ãƒ ã‚’ã‚¹ãƒãƒ¼ãƒ³
    function spawnItem(x, y, type = 'power') {
      // type: 'power', 'bomb', 'life'
      items.push({
        x: x,
        y: y,
        vy: 1.5,
        size: type === 'life' ? 14 : 12,
        type: type
      });
    }
    
    // ãƒœãƒ ã‚¢ã‚¤ãƒ†ãƒ ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã™ã‚‹ã‹ãƒã‚§ãƒƒã‚¯ï¼ˆé“ä¸­ã§1å›ã ã‘ï¼‰
    function tryDropBombItem(x, y) {
      if (!bombItemDropped && Math.random() < 0.15) { // 15%ã®ç¢ºç‡ã§é€šå¸¸æ•µã‹ã‚‰ãƒ‰ãƒ­ãƒƒãƒ—
        spawnItem(x, y, 'bomb');
        bombItemDropped = true;
        return true;
      }
      return false;
    }
    
    // æ•µæ’ƒç ´æ™‚ã®ã‚¢ã‚¤ãƒ†ãƒ ãƒ‰ãƒ­ãƒƒãƒ—å‡¦ç†
    function handleEnemyDrop(e) {
      if (e.isBoss) {
        // å¤§ãƒœã‚¹ã¯å¿…ãšãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—
        spawnItem(e.x, e.y, 'power');
        // 50%ã§æ®‹æ©Ÿã‚¢ãƒƒãƒ—
        if (Math.random() < 0.5) {
          spawnItem(e.x + 30, e.y, 'life');
        }
      } else if (e.isMiniboss) {
        // ä¸­ãƒœã‚¹ã¯å¿…ãšãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—
        spawnItem(e.x, e.y, 'power');
        // ãƒœãƒ ã‚¢ã‚¤ãƒ†ãƒ ãŒã¾ã å‡ºã¦ã„ãªã‘ã‚Œã°ç¢ºå®šãƒ‰ãƒ­ãƒƒãƒ—
        if (!bombItemDropped) {
          spawnItem(e.x - 30, e.y, 'bomb');
          bombItemDropped = true;
        }
      }
    }
    
    // æ•µæ’ƒç ´æ™‚ã®ãƒ•ã‚§ãƒ¼ã‚ºé€²è¡Œ
    function handleEnemyDefeated(e) {
      if (e.isBoss) {
        // å¤§ãƒœã‚¹æ’ƒç ´ â†’ æ¬¡ã®ã‚µã‚¤ã‚¯ãƒ«ã¸
        bossDefeatedCount++;
        bossDefeatedCooldown = BOSS_DEFEATED_COOLDOWN;
        gamePhase = 'normal1';
        phaseTimer = 0;
        bombItemDropped = false; // æ¬¡ã‚µã‚¤ã‚¯ãƒ«ç”¨ã«ãƒªã‚»ãƒƒãƒˆ
        difficulty = Math.min(5, difficulty + 0.5);
      } else if (e.isMiniboss) {
        // ä¸­ãƒœã‚¹æ’ƒç ´ â†’ normal2ãƒ•ã‚§ãƒ¼ã‚ºã¸
        gamePhase = 'normal2';
        phaseTimer = 0;
      }
    }
    
    // æ‰“ã¡è¿”ã—å¼¾ï¼ˆæ•µãŒå€’ã•ã‚ŒãŸæ™‚ã«ç™ºå°„ï¼‰
    function spawnRevengeBullets(x, y, count) {
      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 / count) * i;
        const speed = 2.5 + Math.random() * 1;
        enemyBullets.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          radius: 3
        });
      }
    }
    
    function updateItems() {
      for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        item.y += item.vy;
        
        // ç”»é¢å¤–ã«å‡ºãŸã‚‰å‰Šé™¤
        if (item.y > GAME_HEIGHT + 20) {
          items.splice(i, 1);
          continue;
        }
        
        // ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¨ã®è¡çªåˆ¤å®š
        const dx = item.x - player.x;
        const dy = item.y - player.y;
        if (Math.sqrt(dx*dx + dy*dy) < item.size + 20) {
          if (item.type === 'power') {
            // ãƒ‘ãƒ¯ãƒ¼ã‚¢ãƒƒãƒ—
            if (player.power < 9) {
              player.power++;
            }
            score += 50;
          } else if (item.type === 'bomb') {
            // ãƒœãƒ è¿½åŠ 
            if (player.bombs < player.maxBombs + 2) {
              player.bombs++;
              updateBombButton();
            }
            score += 100;
          } else if (item.type === 'life') {
            // æ®‹æ©Ÿè¿½åŠ 
            lives++;
            score += 200;
          }
          playSound('powerup');
          spawnParticles(item.x, item.y, 5);
          items.splice(i, 1);
        }
      }
    }
    
    function drawItems() {
      for (const item of items) {
        // ã‚¢ã‚¤ãƒ†ãƒ ã‚¿ã‚¤ãƒ—ã«å¿œã˜ãŸè‰²
        let color, text;
        if (item.type === 'power') {
          color = '#00aa00'; // ç·‘
          text = 'P';
        } else if (item.type === 'bomb') {
          color = '#0066ff'; // é’
          text = 'B';
        } else if (item.type === 'life') {
          color = '#ff0066'; // ãƒ”ãƒ³ã‚¯
          text = 'â™¥';
        }
        
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(item.x, item.y, item.size, 0, Math.PI * 2);
        ctx.fill();
        
        // ç™½ã„ç¸å–ã‚Š
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // é»’ã„å¤–æ 
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.stroke();
        
        // æ–‡å­—
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 12px Courier New';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, item.x, item.y);
      }
    }
    
    // ãƒœãƒ ç™ºå‹•
    function useBomb() {
      if (player.bombs <= 0 || bombEffect.active) return;
      
      player.bombs--;
      bombEffect.active = true;
      bombEffect.frame = 0;
      
      playSound('bomb');
      
      // æ•µå¼¾ã¨ãƒ¬ãƒ¼ã‚¶ãƒ¼ã‚’å…¨æ¶ˆå»
      enemyBullets = [];
      lasers = [];
      
      // æ•µã«ãƒ€ãƒ¡ãƒ¼ã‚¸
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        if (e.isBoss) {
          // Lv4ä»¥ä¸Šã§ãƒœã‚¹ã«ãƒœãƒ ã‚’ä½¿ã†ã¨ãƒãƒªã‚¢ã§é˜²ãŒã‚Œã‚‹
          if (player.power >= 4) {
            e.barrier = true;
            e.barrierTimer = 120; // 2ç§’é–“ãƒãƒªã‚¢
            spawnParticles(e.x, e.y, 10);
          } else {
            // å¤§ãƒœã‚¹ã¯HPã‚’25%å‰Šã‚‹
            const damage = Math.ceil(e.maxHp / 4);
            e.hp -= damage;
            spawnParticles(e.x, e.y, 20);
            if (e.hp <= 0) {
              spawnParticles(e.x, e.y, 50);
              handleEnemyDrop(e);
              score += 5000;
              playSound('bossDestroy');
              handleEnemyDefeated(e);
              enemies.splice(i, 1);
            }
          }
        } else if (e.isMiniboss) {
          // Lv4ä»¥ä¸Šã§ä¸­ãƒœã‚¹ã«ãƒœãƒ ã‚’ä½¿ã†ã¨ãƒãƒªã‚¢ã§é˜²ãŒã‚Œã‚‹
          if (player.power >= 4) {
            e.barrier = true;
            e.barrierTimer = 120; // 2ç§’é–“ãƒãƒªã‚¢
            spawnParticles(e.x, e.y, 8);
          } else {
            // ä¸­ãƒœã‚¹ã¯HPã‚’åŠåˆ†å‰Šã‚‹
            const damage = Math.ceil(e.maxHp / 2);
            e.hp -= damage;
            spawnParticles(e.x, e.y, 15);
            if (e.hp <= 0) {
              spawnParticles(e.x, e.y, 25);
              handleEnemyDrop(e);
              score += 1000;
              playSound('bossDestroy');
              handleEnemyDefeated(e);
              enemies.splice(i, 1);
            }
          }
        } else {
          // é€šå¸¸æ•µã¯å³æ­»
          spawnParticles(e.x, e.y, 10);
          score += 100;
          playSound('enemyDestroy');
          enemies.splice(i, 1);
        }
      }
      
      // ãƒœãƒ ä½¿ç”¨ä¸­ã¯ç„¡æ•µ
      player.invincible = Math.max(player.invincible, bombEffect.duration);
      
      updateBombButton();
    }
    
    function updateBombEffect() {
      if (bombEffect.active) {
        bombEffect.frame++;
        if (bombEffect.frame >= bombEffect.duration) {
          bombEffect.active = false;
        }
      }
    }
    
    function drawBombEffect() {
      if (!bombEffect.active) return;
      
      const progress = bombEffect.frame / bombEffect.duration;
      const alpha = Math.sin(progress * Math.PI) * 0.6;
      
      // ç”»é¢å…¨ä½“ã‚’ç™½ããƒ•ãƒ©ãƒƒã‚·ãƒ¥
      ctx.fillStyle = `rgba(0, 0, 0, ${alpha * 0.3})`;
      ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
      
      // ä¸­å¿ƒã‹ã‚‰åºƒãŒã‚‹å††
      const maxRadius = Math.max(GAME_WIDTH, GAME_HEIGHT);
      const radius = progress * maxRadius;
      
      ctx.strokeStyle = `rgba(0, 0, 0, ${(1 - progress) * 0.8})`;
      ctx.lineWidth = 10 * (1 - progress) + 2;
      ctx.beginPath();
      ctx.arc(player.x, player.y, radius, 0, Math.PI * 2);
      ctx.stroke();
      
      // å†…å´ã®å††
      if (progress < 0.5) {
        ctx.strokeStyle = `rgba(0, 0, 0, ${(0.5 - progress) * 0.6})`;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.arc(player.x, player.y, radius * 0.6, 0, Math.PI * 2);
        ctx.stroke();
      }
    }
    
    function updateBombButton() {
      const btn = document.getElementById('bombBtn');
      const count = document.getElementById('bombCount');
      count.textContent = player.bombs;
      
      if (player.bombs <= 0) {
        btn.classList.add('disabled');
      } else {
        btn.classList.remove('disabled');
      }
    }
    
    // æ­¦å™¨åˆ‡ã‚Šæ›¿ãˆ
    function toggleWeapon() {
      if (player.weaponMode === 'shot') {
        player.weaponMode = 'laser';
      } else {
        player.weaponMode = 'shot';
      }
      playSound('weaponSwitch');
      updateWeaponButton();
    }
    
    function updateWeaponButton() {
      const btn = document.getElementById('weaponBtn');
      const icon = document.getElementById('weaponIcon');
      const label = document.getElementById('weaponLabel');
      
      // ç¾åœ¨ã®æ­¦å™¨ã§ã¯ãªãã€åˆ‡ã‚Šæ›¿ãˆå…ˆã®æ­¦å™¨ã‚’è¡¨ç¤º
      if (player.weaponMode === 'shot') {
        // ç¾åœ¨ã‚·ãƒ§ãƒƒãƒˆ â†’ ãƒœã‚¿ãƒ³ã«ã¯ã€Œãƒ¬ãƒ¼ã‚¶ãƒ¼ã«åˆ‡ã‚Šæ›¿ãˆã€ã‚’è¡¨ç¤º
        btn.classList.remove('shot-mode');
        btn.classList.add('laser-mode');
        icon.textContent = '|';
        label.textContent = 'LASER';
      } else {
        // ç¾åœ¨ãƒ¬ãƒ¼ã‚¶ãƒ¼ â†’ ãƒœã‚¿ãƒ³ã«ã¯ã€Œã‚·ãƒ§ãƒƒãƒˆã«åˆ‡ã‚Šæ›¿ãˆã€ã‚’è¡¨ç¤º
        btn.classList.remove('laser-mode');
        btn.classList.add('shot-mode');
        icon.textContent = '///';
        label.textContent = 'SHOT';
      }
    }
    
    // ã‚ªãƒ¼ãƒˆãƒ‘ã‚¤ãƒ­ãƒƒãƒˆåˆ‡ã‚Šæ›¿ãˆ
    function toggleAutoPilot() {
      autoPilot = !autoPilot;
      if (autoPilot) {
        // ã‚ªãƒ¼ãƒˆãƒ‘ã‚¤ãƒ­ãƒƒãƒˆé–‹å§‹æ™‚ã«ç¾åœ¨ä½ç½®ã‹ã‚‰é–‹å§‹
        autoTargetX = player.x;
        autoTargetY = player.y;
        autoVelocityX = 0;
        autoVelocityY = 0;
      }
      updateAutoButton();
      playSound('weaponSwitch');
    }
    
    function updateAutoButton() {
      const btn = document.getElementById('autoBtn');
      if (autoPilot) {
        btn.classList.add('active');
      } else {
        btn.classList.remove('active');
      }
    }
    
    function updateParticles() {
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.vx *= 0.95;
        p.vy *= 0.95;
        
        // æ®‹éª¸ã¯é‡åŠ›ã®å½±éŸ¿ã‚’å—ã‘ã‚‹
        if (p.type === 'debris') {
          p.vy += 0.1;
          if (p.rotation !== undefined) {
            p.rotation += p.rotationSpeed;
          }
        }
        
        p.life--;
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }
    }
    
    function drawParticles() {
      for (const p of particles) {
        const alpha = Math.min(1, p.life / 30);
        
        if (p.type === 'explosion') {
          // çˆ†ç™ºãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆæ˜ã‚‹ã„â†’æš—ã„ï¼‰
          const brightness = Math.floor(100 + (1 - alpha) * 100);
          ctx.fillStyle = `rgba(${brightness}, ${brightness}, ${brightness}, ${alpha})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
          ctx.fill();
        } else if (p.type === 'ring') {
          // ãƒªãƒ³ã‚°çŠ¶ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
          ctx.fillStyle = `rgba(50, 50, 50, ${alpha})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        } else if (p.type === 'spark') {
          // ç«èŠ±ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆå°¾ã‚’å¼•ãï¼‰
          const c = p.color;
          const tailLength = Math.sqrt(p.vx * p.vx + p.vy * p.vy) * 2;
          
          // å°¾ã®æç”»
          const gradient = ctx.createLinearGradient(
            p.x, p.y,
            p.x - p.vx * 2, p.y - p.vy * 2
          );
          gradient.addColorStop(0, `rgba(${c.r}, ${c.g}, ${c.b}, ${alpha})`);
          gradient.addColorStop(1, `rgba(${c.r}, ${c.g}, ${c.b}, 0)`);
          
          ctx.strokeStyle = gradient;
          ctx.lineWidth = p.size;
          ctx.lineCap = 'round';
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(p.x - p.vx * 2, p.y - p.vy * 2);
          ctx.stroke();
          
          // å…ˆç«¯ã®å…‰
          ctx.fillStyle = `rgba(${c.r}, ${c.g}, ${c.b}, ${alpha})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * 0.8, 0, Math.PI * 2);
          ctx.fill();
        } else if (p.type === 'flash') {
          // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ï¼ˆä¸­å¿ƒã®æ˜ã‚‹ã„å…‰ï¼‰
          const c = p.color;
          const flashAlpha = alpha * 0.8;
          const gradient = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, p.size);
          gradient.addColorStop(0, `rgba(${c.r}, ${c.g}, ${c.b}, ${flashAlpha})`);
          gradient.addColorStop(0.3, `rgba(${c.r}, ${c.g}, ${c.b}, ${flashAlpha * 0.5})`);
          gradient.addColorStop(1, `rgba(${c.r}, ${c.g}, ${c.b}, 0)`);
          
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx.fill();
        } else if (p.type === 'grazeRing') {
          // ã‚°ãƒ¬ã‚¤ã‚ºãƒªãƒ³ã‚°ï¼ˆåºƒãŒã‚‹è¼ªï¼‰
          const c = p.color;
          const progress = 1 - (p.life / 12);
          const currentSize = p.size + (p.maxSize - p.size) * progress;
          const ringAlpha = alpha * 0.6;
          
          ctx.strokeStyle = `rgba(${c.r}, ${c.g}, ${c.b}, ${ringAlpha})`;
          ctx.lineWidth = 2 * alpha;
          ctx.beginPath();
          ctx.arc(p.x, p.y, currentSize, 0, Math.PI * 2);
          ctx.stroke();
        } else if (p.type === 'graze') {
          // æ—§ã‚°ãƒ¬ã‚¤ã‚ºãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆäº’æ›æ€§ã®ãŸã‚æ®‹ã™ï¼‰
          ctx.fillStyle = `rgba(100, 200, 255, ${alpha})`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.size * alpha, 0, Math.PI * 2);
          ctx.fill();
        } else if (p.type === 'debris') {
          // æ®‹éª¸ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼ˆå›è»¢ã™ã‚‹å››è§’å½¢ï¼‰
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rotation || 0);
          ctx.fillStyle = `rgba(${getFgColorRgb()}, ${alpha})`;
          ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size);
          ctx.restore();
        } else {
          // é€šå¸¸ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
          ctx.fillStyle = `rgba(${getFgColorRgb()}, ${alpha})`;
          ctx.fillRect(p.x - p.size/2, p.y - p.size/2, p.size, p.size);
        }
      }
    }
    
    // ã‚°ãƒ¬ã‚¤ã‚ºå‡¦ç†
    function checkGraze() {
      if (player.invincible > 0 || gameOverPending) return;
      
      // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æ›´æ–°
      if (grazeCooldown > 0) grazeCooldown--;
      
      let grazedThisFrame = false;
      
      for (const b of enemyBullets) {
        // å¼¾ã”ã¨ã«ãƒ¦ãƒ‹ãƒ¼ã‚¯IDã‚’ç”Ÿæˆï¼ˆä½ç½®ã¨é€Ÿåº¦ã‹ã‚‰ï¼‰
        const bulletId = `${Math.round(b.x)}_${Math.round(b.y)}_${Math.round(b.vx*10)}_${Math.round(b.vy*10)}`;
        
        // æ—¢ã«ã‚°ãƒ¬ã‚¤ã‚ºã—ãŸå¼¾ã¯ã‚¹ã‚­ãƒƒãƒ—
        if (grazedBullets.has(bulletId)) continue;
        
        const dx = b.x - player.x;
        const dy = b.y - player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        // ã‚°ãƒ¬ã‚¤ã‚ºåˆ¤å®šï¼šå½“ãŸã‚Šåˆ¤å®šã‚ˆã‚Šå¤–å´ã€ã‚°ãƒ¬ã‚¤ã‚ºåŠå¾„ã‚ˆã‚Šå†…å´
        if (dist > b.radius + player.hitboxRadius && dist < GRAZE_RADIUS + b.radius) {
          // ã‚°ãƒ¬ã‚¤ã‚ºæˆåŠŸ
          grazedBullets.add(bulletId);
          grazeCount++;
          grazeCombo++;
          
          // ã‚³ãƒ³ãƒœãƒœãƒ¼ãƒŠã‚¹ä»˜ãã‚¹ã‚³ã‚¢
          const comboBonus = Math.min(grazeCombo, 10);
          score += GRAZE_SCORE * comboBonus;
          
          grazedThisFrame = true;
          
          // æ¥è§¦ç‚¹ã‚’è¨ˆç®—ï¼ˆè‡ªæ©Ÿã¨å¼¾ã®é–“ï¼‰
          const angle = Math.atan2(dy, dx);
          const contactX = player.x + Math.cos(angle) * (player.hitboxRadius + 5);
          const contactY = player.y + Math.sin(angle) * (player.hitboxRadius + 5);
          
          // ç«èŠ±ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼ˆå¤§é‡ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼‰
          spawnGrazeSparks(contactX, contactY, angle, b.vx, b.vy);
        }
      }
      
      // ã‚°ãƒ¬ã‚¤ã‚ºéŸ³ï¼ˆé–“å¼•ã„ã¦å†ç”Ÿï¼‰
      if (grazedThisFrame && grazeCooldown <= 0) {
        playSound('graze');
        grazeCooldown = 3; // 3ãƒ•ãƒ¬ãƒ¼ãƒ é–“éš”
      }
      
      // ã‚°ãƒ¬ã‚¤ã‚ºãŒãªã‘ã‚Œã°ã‚³ãƒ³ãƒœãƒªã‚»ãƒƒãƒˆ
      if (!grazedThisFrame) {
        // å°‘ã—çŒ¶äºˆã‚’æŒãŸã›ã‚‹
        if (grazeCombo > 0 && frameCount % 10 === 0) {
          grazeCombo = Math.max(0, grazeCombo - 1);
        }
      }
      
      // ç”»é¢å¤–ã«å‡ºãŸå¼¾ã®ã‚°ãƒ¬ã‚¤ã‚ºè¨˜éŒ²ã‚’ã‚¯ãƒªã‚¢
      if (frameCount % 60 === 0) {
        grazedBullets.clear();
      }
    }
    
    // ã‚°ãƒ¬ã‚¤ã‚ºç«èŠ±ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
    function spawnGrazeSparks(x, y, angle, bulletVx, bulletVy) {
      // ç«èŠ±ã®è‰²ãƒ‘ãƒ¬ãƒƒãƒˆï¼ˆç™½â†’é»„â†’ã‚ªãƒ¬ãƒ³ã‚¸ï¼‰
      const colors = [
        { r: 255, g: 255, b: 255 },  // ç™½
        { r: 255, g: 255, b: 200 },  // è–„é»„
        { r: 255, g: 230, b: 100 },  // é»„
        { r: 255, g: 180, b: 50 },   // ã‚ªãƒ¬ãƒ³ã‚¸
        { r: 100, g: 200, b: 255 },  // æ°´è‰²
      ];
      
      // ãƒ¡ã‚¤ãƒ³ç«èŠ±ï¼ˆå¼¾ã®é€²è¡Œæ–¹å‘ã«é£›ã³æ•£ã‚‹ï¼‰
      for (let i = 0; i < 12; i++) {
        const spread = (Math.random() - 0.5) * Math.PI * 0.8;
        const sparkAngle = angle + Math.PI + spread; // å¼¾ã‹ã‚‰é€ƒã’ã‚‹æ–¹å‘
        const speed = 3 + Math.random() * 6;
        const color = colors[Math.floor(Math.random() * colors.length)];
        
        particles.push({
          x: x + (Math.random() - 0.5) * 6,
          y: y + (Math.random() - 0.5) * 6,
          vx: Math.cos(sparkAngle) * speed + bulletVx * 0.3,
          vy: Math.sin(sparkAngle) * speed + bulletVy * 0.3,
          life: 15 + Math.random() * 15,
          size: 1.5 + Math.random() * 2.5,
          type: 'spark',
          color: color
        });
      }
      
      // ç´°ã‹ã„ç«èŠ±ï¼ˆãƒ©ãƒ³ãƒ€ãƒ æ–¹å‘ï¼‰
      for (let i = 0; i < 8; i++) {
        const sparkAngle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 4;
        const color = colors[Math.floor(Math.random() * colors.length)];
        
        particles.push({
          x: x,
          y: y,
          vx: Math.cos(sparkAngle) * speed,
          vy: Math.sin(sparkAngle) * speed,
          life: 10 + Math.random() * 10,
          size: 1 + Math.random() * 1.5,
          type: 'spark',
          color: color
        });
      }
      
      // ãƒ•ãƒ©ãƒƒã‚·ãƒ¥ï¼ˆä¸­å¿ƒã®æ˜ã‚‹ã„å…‰ï¼‰
      particles.push({
        x: x,
        y: y,
        vx: 0,
        vy: 0,
        life: 8,
        size: 12 + Math.random() * 8,
        type: 'flash',
        color: { r: 255, g: 255, b: 255 }
      });
      
      // ãƒªãƒ³ã‚°ï¼ˆåºƒãŒã‚‹è¼ªï¼‰
      particles.push({
        x: x,
        y: y,
        vx: 0,
        vy: 0,
        life: 12,
        size: 5,
        maxSize: 25,
        type: 'grazeRing',
        color: { r: 100, g: 200, b: 255 }
      });
    }
    
    // Collision detection
    function checkCollisions() {
      // Player bullets vs enemies
      for (let i = playerBullets.length - 1; i >= 0; i--) {
        const b = playerBullets[i];
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          if (Math.abs(b.x - e.x) < e.width/2 && Math.abs(b.y - e.y) < e.height/2) {
            playerBullets.splice(i, 1);
            
            // ç™»å ´ä¸­ã¾ãŸã¯ãƒãƒªã‚¢ä¸­ã¯ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆãªã„
            if ((e.isMiniboss || e.isBoss) && (e.entryPhase || e.barrier)) {
              // ãƒãƒªã‚¢ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
              if (e.barrier && frameCount % 3 === 0) {
                spawnParticles(b.x, b.y, 1);
              }
              break;
            }
            
            e.hp--;
            if (e.hp <= 0) {
              const particleCount = e.isBoss ? 50 : (e.isMiniboss ? 25 : 10);
              spawnParticles(e.x, e.y, particleCount);
              
              // ã‚¢ã‚¤ãƒ†ãƒ ãƒ‰ãƒ­ãƒƒãƒ—
              handleEnemyDrop(e);
              
              // ã‚¹ã‚³ã‚¢
              score += e.isBoss ? 5000 : (e.isMiniboss ? 1000 : 100);
              
              // åŠ¹æœéŸ³
              playSound((e.isBoss || e.isMiniboss) ? 'bossDestroy' : 'enemyDestroy');
              
              // æ‰“ã¡è¿”ã—å¼¾ï¼ˆãƒ‘ãƒ¯ãƒ¼ãƒ¬ãƒ™ãƒ«4ä»¥ä¸Šã§é€šå¸¸æ•µãŒç™ºå°„ï¼‰
              if (!e.isMiniboss && !e.isBoss && player.power >= 4) {
                const bulletCount = 4 + Math.floor((player.power - 4) / 2) * 2;
                spawnRevengeBullets(e.x, e.y, bulletCount);
              }
              
              // ãƒ•ã‚§ãƒ¼ã‚ºé€²è¡Œ
              handleEnemyDefeated(e);
              
              enemies.splice(j, 1);
            }
            break;
          }
        }
      }
      
      // Homing bullets vs enemies
      for (let i = homingBullets.length - 1; i >= 0; i--) {
        const h = homingBullets[i];
        for (let j = enemies.length - 1; j >= 0; j--) {
          const e = enemies[j];
          const dx = h.x - e.x;
          const dy = h.y - e.y;
          if (Math.sqrt(dx*dx + dy*dy) < h.radius + Math.max(e.width, e.height)/2) {
            homingBullets.splice(i, 1);
            
            // ç™»å ´ä¸­ã¾ãŸã¯ãƒãƒªã‚¢ä¸­ã¯ãƒ€ãƒ¡ãƒ¼ã‚¸ã‚’ä¸ãˆãªã„
            if ((e.isMiniboss || e.isBoss) && (e.entryPhase || e.barrier)) {
              spawnParticles(h.x, h.y, 2);
              break;
            }
            
            e.hp--;
            spawnParticles(h.x, h.y, 5);
            if (e.hp <= 0) {
              const particleCount = e.isBoss ? 50 : (e.isMiniboss ? 25 : 10);
              spawnParticles(e.x, e.y, particleCount);
              
              // ã‚¢ã‚¤ãƒ†ãƒ ãƒ‰ãƒ­ãƒƒãƒ—
              handleEnemyDrop(e);
              
              // ã‚¹ã‚³ã‚¢
              score += e.isBoss ? 5000 : (e.isMiniboss ? 1000 : 100);
              
              // åŠ¹æœéŸ³
              playSound((e.isBoss || e.isMiniboss) ? 'bossDestroy' : 'enemyDestroy');
              
              // æ‰“ã¡è¿”ã—å¼¾
              if (!e.isMiniboss && !e.isBoss && player.power >= 4) {
                const bulletCount = 4 + Math.floor((player.power - 4) / 2) * 2;
                spawnRevengeBullets(e.x, e.y, bulletCount);
              }
              
              // ãƒ•ã‚§ãƒ¼ã‚ºé€²è¡Œ
              handleEnemyDefeated(e);
              
              enemies.splice(j, 1);
            }
            break;
          }
        }
      }
      
      // Enemy bullets vs player (å½“ãŸã‚Šåˆ¤å®šã¯å°ã•ã„èµ¤ã„ãƒ‰ãƒƒãƒˆéƒ¨åˆ†ã®ã¿)
      if (player.invincible === 0 && !gameOverPending) {
        for (let i = enemyBullets.length - 1; i >= 0; i--) {
          const b = enemyBullets[i];
          const dx = b.x - player.x;
          const dy = b.y - player.y;
          if (Math.sqrt(dx*dx + dy*dy) < b.radius + player.hitboxRadius) {
            enemyBullets.splice(i, 1);
            lives--;
            player.invincible = 120;
            // è¢«å¼¾ã§ãƒ‘ãƒ¯ãƒ¼ãƒ€ã‚¦ãƒ³ï¼ˆ2æ®µéšä¸‹ãŒã‚‹ï¼‰
            player.power = Math.max(0, player.power - 2);
            spawnParticles(player.x, player.y, 15);
            
            playSound('playerHit');
            
            // ãƒœãƒ ã‚¿ã‚¤ãƒ—ã¯è¢«å¼¾æ™‚ã«ãƒœãƒ å›å¾©
            if (SHIP_TYPES[player.shipType].bombRecovery && player.bombs < player.maxBombs) {
              player.bombs++;
              updateBombButton();
            }
            
            if (lives <= 0) {
              // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å¾…æ©ŸçŠ¶æ…‹ã¸
              gameOverPending = true;
              gameOverTimer = 0;
              playSound('playerDeath');
              spawnDeathExplosion(player.x, player.y);
            }
            break;
          }
        }
      }
      
      // Enemy collision with player
      if (player.invincible === 0 && !gameOverPending) {
        for (const e of enemies) {
          if (Math.abs(e.x - player.x) < (e.width + player.width)/2 - 5 &&
              Math.abs(e.y - player.y) < (e.height + player.height)/2 - 5) {
            lives--;
            player.invincible = 120;
            // è¢«å¼¾ã§ãƒ‘ãƒ¯ãƒ¼ãƒ€ã‚¦ãƒ³ï¼ˆ2æ®µéšä¸‹ãŒã‚‹ï¼‰
            player.power = Math.max(0, player.power - 2);
            spawnParticles(player.x, player.y, 15);
            
            playSound('playerHit');
            
            // ãƒœãƒ ã‚¿ã‚¤ãƒ—ã¯è¢«å¼¾æ™‚ã«ãƒœãƒ å›å¾©
            if (SHIP_TYPES[player.shipType].bombRecovery && player.bombs < player.maxBombs) {
              player.bombs++;
              updateBombButton();
            }
            
            if (lives <= 0) {
              // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å¾…æ©ŸçŠ¶æ…‹ã¸
              gameOverPending = true;
              gameOverTimer = 0;
              playSound('playerDeath');
              spawnDeathExplosion(player.x, player.y);
            }
            break;
          }
        }
      }
    }
    
    // UI update
    function updateUI() {
      const powerText = player.power >= 9 ? 'MAX' : `Lv.${player.power}`;
      let scoreText = `SCORE: ${score}`;
      if (grazeCount > 0) {
        scoreText += ` GRAZE: ${grazeCount}`;
        if (grazeCombo > 1) {
          scoreText += `<span style="color:#0088ff">x${Math.min(grazeCombo, 10)}</span>`;
        }
      }
      document.getElementById('scoreDisplay').innerHTML = scoreText;
      let livesHtml = `<span style="color:#00aa00">${powerText}</span>&nbsp;&nbsp;${'â™¥'.repeat(Math.max(0, lives))}`;
      if (autoPilot) {
        livesHtml += `&nbsp;<span style="color:#0066ff;font-size:10px">AUTO</span>`;
      }
      document.getElementById('livesDisplay').innerHTML = livesHtml;
    }
    
    // Game loop
    function gameLoop() {
      if (!gameRunning) return;
      if (gamePaused) {
        requestAnimationFrame(gameLoop);
        return;
      }
      
      // Clear
      ctx.fillStyle = getBgColor();
      ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
      
      // ã‚ªãƒ¼ãƒˆãƒ‘ã‚¤ãƒ­ãƒƒãƒˆ
      runAutoPilot();
      
      // Update
      updatePlayer();
      updateEnemies();
      updateBullets();
      updateHomingBullets();
      updateLasers();
      updateItems();
      updateParticles();
      updateBombEffect();
      checkGraze();
      checkCollisions();
      
      // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼å¾…æ©Ÿä¸­ã®å‡¦ç†
      if (gameOverPending) {
        gameOverTimer++;
        if (gameOverTimer >= GAME_OVER_DELAY) {
          gameOver();
          return;
        }
      }
      
      // Spawn enemies based on game phase
      const hasBoss = enemies.some(e => e.isBoss);
      const hasMiniboss = enemies.some(e => e.isMiniboss);
      
      // ã‚¯ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³æ›´æ–°
      if (bossDefeatedCooldown > 0) {
        bossDefeatedCooldown--;
      }
      
      // ãƒ•ã‚§ãƒ¼ã‚ºã«å¿œã˜ãŸæ•µã‚¹ãƒãƒ¼ãƒ³
      if (!hasBoss && !hasMiniboss && bossDefeatedCooldown <= 0) {
        phaseTimer++;
        
        if (gamePhase === 'normal1') {
          // é€šå¸¸ãƒ•ã‚§ãƒ¼ã‚º1: é€šå¸¸æ•µã‚’å‡ºã™
          const spawnRate = Math.max(30, 90 - difficulty * 10);
          if (frameCount % spawnRate === 0) {
            spawnEnemy();
          }
          // æ™‚é–“çµŒéã§ä¸­ãƒœã‚¹ãƒ•ã‚§ãƒ¼ã‚ºã¸
          if (phaseTimer >= NORMAL_PHASE_DURATION) {
            gamePhase = 'miniboss';
            phaseTimer = 0;
          }
        } else if (gamePhase === 'miniboss') {
          // ä¸­ãƒœã‚¹å‡ºç¾
          spawnMiniboss();
          gamePhase = 'waiting'; // ä¸­ãƒœã‚¹æ’ƒç ´å¾…ã¡
          phaseTimer = 0;
        } else if (gamePhase === 'normal2') {
          // é€šå¸¸ãƒ•ã‚§ãƒ¼ã‚º2: é€šå¸¸æ•µã‚’å‡ºã™
          const spawnRate = Math.max(25, 80 - difficulty * 10);
          if (frameCount % spawnRate === 0) {
            spawnEnemy();
          }
          // æ™‚é–“çµŒéã§å¤§ãƒœã‚¹ãƒ•ã‚§ãƒ¼ã‚ºã¸
          if (phaseTimer >= NORMAL_PHASE_DURATION) {
            gamePhase = 'boss';
            phaseTimer = 0;
          }
        } else if (gamePhase === 'boss') {
          // å¤§ãƒœã‚¹å‡ºç¾
          spawnBoss();
          gamePhase = 'waiting'; // å¤§ãƒœã‚¹æ’ƒç ´å¾…ã¡
          phaseTimer = 0;
        }
      }
      
      // Draw (ãƒ¬ãƒ¼ã‚¶ãƒ¼ã¯æœ€èƒŒé¢ã«æç”»ã—ã¦æ•µå¼¾ãŒè¦‹ãˆã‚‹ã‚ˆã†ã«)
      drawPlayerLaser();
      drawLasers();
      drawItems();
      drawEnemies();
      drawBullets();
      drawHomingBullets();
      drawPlayer();
      drawParticles();
      drawBombEffect();
      
      // UI
      updateUI();
      
      frameCount++;
      requestAnimationFrame(gameLoop);
    }
    
    // Touch controls
    function getCanvasCoords(clientX, clientY) {
      const rect = canvas.getBoundingClientRect();
      const scaleX = GAME_WIDTH / rect.width;
      const scaleY = GAME_HEIGHT / rect.height;
      return {
        x: (clientX - rect.left) * scaleX,
        y: (clientY - rect.top) * scaleY
      };
    }
    
    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const coords = getCanvasCoords(touch.clientX, touch.clientY);
      player.targetX = coords.x;
      player.targetY = coords.y - TOUCH_OFFSET_Y; // ã‚¿ãƒƒãƒä½ç½®ã‚ˆã‚Šä¸Šã«é…ç½®
    }, { passive: false });
    
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const coords = getCanvasCoords(touch.clientX, touch.clientY);
      player.targetX = coords.x;
      player.targetY = coords.y - TOUCH_OFFSET_Y; // ã‚¿ãƒƒãƒä½ç½®ã‚ˆã‚Šä¸Šã«é…ç½®
    }, { passive: false });
    
    // Mouse controls (for desktop testing)
    canvas.addEventListener('mousemove', (e) => {
      if (!gameRunning) return;
      const coords = getCanvasCoords(e.clientX, e.clientY);
      player.targetX = coords.x;
      player.targetY = coords.y;
    });
    
    canvas.addEventListener('mousedown', (e) => {
      const coords = getCanvasCoords(e.clientX, e.clientY);
      player.targetX = coords.x;
      player.targetY = coords.y;
    });
    
    // Game state functions
    // æ©Ÿä½“é¸æŠçŠ¶æ…‹
    let selectedShip = 'shot';
    
    function showShipSelect() {
      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      document.getElementById('shipSelectScreen').classList.remove('hidden');
      
      // ã‚²ãƒ¼ãƒ çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
      gameRunning = false;
      gamePaused = false;
      gameOverPending = false;
      autoPilot = false;
      stopBGM();
      
      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆé¸æŠ
      selectedShip = 'shot';
      document.querySelectorAll('.ship-btn').forEach(btn => {
        btn.classList.remove('selected');
        if (btn.dataset.ship === selectedShip) {
          btn.classList.add('selected');
        }
      });
    }
    
    function showTitleScreen() {
      document.getElementById('shipSelectScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      document.getElementById('startScreen').classList.remove('hidden');
      updateBgmDisplay();
    }
    
    function startGame() {
      // ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªåˆæœŸåŒ–
      initAudio();
      
      document.getElementById('startScreen').classList.add('hidden');
      document.getElementById('gameOverScreen').classList.add('hidden');
      document.getElementById('shipSelectScreen').classList.add('hidden');
      document.getElementById('pauseScreen').classList.add('hidden');
      document.getElementById('bombBtn').classList.remove('hidden');
      document.getElementById('weaponBtn').classList.remove('hidden');
      document.getElementById('pauseBtn').classList.remove('hidden');
      document.getElementById('autoBtn').classList.remove('hidden');
      
      // ã‚ªãƒ¼ãƒˆãƒ‘ã‚¤ãƒ­ãƒƒãƒˆã‚’ãƒªã‚»ãƒƒãƒˆ
      autoPilot = false;
      updateAutoButton();
      
      // æ©Ÿä½“ã‚¿ã‚¤ãƒ—è¨­å®š
      player.shipType = selectedShip;
      const shipConfig = SHIP_TYPES[player.shipType];
      player.maxBombs = shipConfig.bombs;
      player.bombs = shipConfig.bombs;
      
      // Reset game state
      score = 0;
      lives = 3;
      frameCount = 0;
      difficulty = 1;
      gamePhase = 'normal1';
      phaseTimer = 0;
      bossDefeatedCount = 0;
      bombItemDropped = false;
      bossDefeatedCooldown = 0;
      gameOverPending = false;
      gameOverTimer = 0;
      player.x = GAME_WIDTH / 2;
      player.y = GAME_HEIGHT - 200;
      player.targetX = GAME_WIDTH / 2;
      player.targetY = GAME_HEIGHT - 200;
      player.invincible = 60;
      player.power = 0;
      player.lastFire = 0;
      player.bombs = shipConfig.bombs;
      player.lastHomingFire = 0;
      player.weaponMode = 'shot';
      player.laserActive = false;
      player.laserDamageTimer = 0;
      bombEffect.active = false;
      bombEffect.frame = 0;
      playerBullets = [];
      homingBullets = [];
      playerLaser = null;
      enemies = [];
      enemyBullets = [];
      lasers = [];
      particles = [];
      items = [];
      
      // ã‚ªãƒ¼ãƒˆãƒ‘ã‚¤ãƒ­ãƒƒãƒˆé–¢é€£ãƒªã‚»ãƒƒãƒˆ
      autoTargetX = GAME_WIDTH / 2;
      autoTargetY = GAME_HEIGHT - 200;
      autoVelocityX = 0;
      autoVelocityY = 0;
      
      // ã‚°ãƒ¬ã‚¤ã‚ºé–¢é€£ãƒªã‚»ãƒƒãƒˆ
      grazeCount = 0;
      grazeCombo = 0;
      grazeCooldown = 0;
      grazedBullets.clear();
      
      updateBombButton();
      updateWeaponButton();
      
      // BGMé–‹å§‹
      startBGM(currentBgmTrack);
      
      gameRunning = true;
      gamePaused = false;
      gameLoop();
    }
    
    function gameOver() {
      gameRunning = false;
      gamePaused = false;
      gameOverPending = false;
      gameOverTimer = 0;
      autoPilot = false;
      stopBGM();
      document.getElementById('finalScore').textContent = score;
      document.getElementById('gameOverScreen').classList.remove('hidden');
      document.getElementById('bombBtn').classList.add('hidden');
      document.getElementById('weaponBtn').classList.add('hidden');
      document.getElementById('pauseBtn').classList.add('hidden');
      document.getElementById('autoBtn').classList.add('hidden');
      document.getElementById('pauseScreen').classList.add('hidden');
    }
    
    function pauseGame() {
      if (!gameRunning || gamePaused) return;
      gamePaused = true;
      document.getElementById('pauseScreen').classList.remove('hidden');
      document.getElementById('bombBtn').classList.add('hidden');
      document.getElementById('weaponBtn').classList.add('hidden');
    }
    
    function resumeGame() {
      if (!gamePaused) return;
      gamePaused = false;
      document.getElementById('pauseScreen').classList.add('hidden');
      document.getElementById('bombBtn').classList.remove('hidden');
      document.getElementById('weaponBtn').classList.remove('hidden');
    }
    
    function quitGame() {
      gameRunning = false;
      gamePaused = false;
      document.getElementById('pauseScreen').classList.add('hidden');
      document.getElementById('bombBtn').classList.add('hidden');
      document.getElementById('weaponBtn').classList.add('hidden');
      document.getElementById('pauseBtn').classList.add('hidden');
      document.getElementById('shipSelectScreen').classList.add('hidden');
      document.getElementById('startScreen').classList.remove('hidden');
    }
    
    // Button handlers
    document.getElementById('startBtn').addEventListener('click', showShipSelect);
    document.getElementById('restartBtn').addEventListener('click', showShipSelect);
    
    // æ©Ÿä½“é¸æŠãƒœã‚¿ãƒ³
    document.querySelectorAll('.ship-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        selectedShip = btn.dataset.ship;
        document.querySelectorAll('.ship-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
      });
    });
    
    document.getElementById('confirmShipBtn').addEventListener('click', startGame);
    
    document.getElementById('bombBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (gameRunning && !gamePaused) {
        useBomb();
      }
    });
    document.getElementById('bombBtn').addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (gameRunning && !gamePaused) {
        useBomb();
      }
    }, { passive: false });
    
    // Pause button handlers
    document.getElementById('pauseBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      pauseGame();
    });
    document.getElementById('pauseBtn').addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      pauseGame();
    }, { passive: false });
    
    document.getElementById('resumeBtn').addEventListener('click', resumeGame);
    document.getElementById('quitBtn').addEventListener('click', quitGame);
    
    // æ­¦å™¨åˆ‡ã‚Šæ›¿ãˆãƒœã‚¿ãƒ³
    document.getElementById('weaponBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (gameRunning && !gamePaused) {
        toggleWeapon();
      }
    });
    document.getElementById('weaponBtn').addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (gameRunning && !gamePaused) {
        toggleWeapon();
      }
    }, { passive: false });
    
    // ã‚ªãƒ¼ãƒˆãƒ‘ã‚¤ãƒ­ãƒƒãƒˆãƒœã‚¿ãƒ³
    document.getElementById('autoBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (gameRunning && !gamePaused) {
        toggleAutoPilot();
      }
    });
    document.getElementById('autoBtn').addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      if (gameRunning && !gamePaused) {
        toggleAutoPilot();
      }
    }, { passive: false });
    
    // ãƒ€ãƒ¼ã‚¯ãƒ¢ãƒ¼ãƒ‰ãƒœã‚¿ãƒ³ï¼ˆè¤‡æ•°ã®ç”»é¢ã«å­˜åœ¨ï¼‰
    document.querySelectorAll('#darkModeBtn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        toggleDarkMode();
      });
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        e.stopPropagation();
        toggleDarkMode();
      }, { passive: false });
    });
    
    // BGMé¸æŠï¼ˆã‚¿ã‚¤ãƒˆãƒ«ç”»é¢ç”¨ï¼‰
    function updateBgmDisplay() {
      const display = document.getElementById('bgmNameDisplay');
      if (display) {
        display.textContent = BGM_TRACKS[currentBgmTrack].name;
      }
    }
    
    function selectPrevBgm() {
      currentBgmTrack = (currentBgmTrack - 1 + BGM_TRACKS.length) % BGM_TRACKS.length;
      updateBgmDisplay();
    }
    
    function selectNextBgm() {
      currentBgmTrack = (currentBgmTrack + 1) % BGM_TRACKS.length;
      updateBgmDisplay();
    }
    
    document.getElementById('bgmPrevBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      selectPrevBgm();
    });
    document.getElementById('bgmPrevBtn').addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      selectPrevBgm();
    }, { passive: false });
    
    document.getElementById('bgmNextBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      selectNextBgm();
    });
    document.getElementById('bgmNextBtn').addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      selectNextBgm();
    }, { passive: false });
    
    // æˆ»ã‚‹ãƒœã‚¿ãƒ³ï¼ˆæ©Ÿä½“é¸æŠâ†’ã‚¿ã‚¤ãƒˆãƒ«ï¼‰
    document.getElementById('backToTitleBtn').addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      showTitleScreen();
    });
    document.getElementById('backToTitleBtn').addEventListener('touchstart', (e) => {
      e.preventDefault();
      e.stopPropagation();
      showTitleScreen();
    }, { passive: false });
  </script>
</body>
</html>
